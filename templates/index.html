<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CULTIST</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Creepster&display=swap" rel="stylesheet">
  <style>
    body { font-family:"Inter",sans-serif; background:#1a202c; color:#e2e8f0; display:flex; flex-direction:column; min-height:100vh; }
    .container { max-width:1200px; margin:auto; padding:1rem; flex-grow:1; }
    .action-button { @apply w-full font-bold py-3 px-6 rounded-lg shadow-lg transition duration-200 ease-in-out; }
    .dialog-overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:flex; justify-content:center; align-items:center; z-index:1000; }
    .dialog-content { background:#2d3748; padding:1.5rem; border-radius:.5rem; box-shadow:0 10px 15px rgba(0,0,0,0.3); max-width:90%; width: 500px; max-height:90%; overflow-y:auto; color:#e2e8f0; }
    .disabled-button { @apply bg-gray-500 text-gray-300 cursor-not-allowed; }
    
    #action-button.sleep-button { background:#8b5cf6; } 
    #action-button.sleep-button:hover { background:#7c3aed; }
    #action-button.kill-ready-button, #action-button.kill-vote-button { background:#b91c1c; }
    #action-button.kill-ready-button:hover, #action-button.kill-vote-button:hover { background:#991b1b; }
    
    @keyframes pulse-flame {
      0%, 100% { 
        transform: scale(1);
        box-shadow: var(--shadow-color-start); 
      }
      50% { 
        transform: scale(1.02);
        box-shadow: var(--shadow-color-end); 
      }
    }

    .animate-pulse-flame {
      animation: pulse-flame 1.5s infinite ease-in-out;
    }

    @keyframes flicker {
        0%, 100% {
            box-shadow: 
                0 0 5px rgba(255, 165, 0, 0.8),
                0 0 10px rgba(255, 165, 0, 0.6),
                0 0 15px rgba(255, 69, 0, 0.5),
                0 0 20px rgba(255, 0, 0, 0.4);
            border-color: rgba(255, 165, 0, 0.9);
            text-shadow: 0 0 3px rgba(255, 165, 0, 0.7);
        }
        50% {
            box-shadow: 
                0 0 8px rgba(255, 200, 0, 0.9),
                0 0 16px rgba(255, 165, 0, 0.8),
                0 0 24px rgba(255, 69, 0, 0.7),
                0 0 32px rgba(255, 0, 0, 0.5);
            border-color: rgba(255, 200, 0, 1);
            text-shadow: 0 0 5px rgba(255, 200, 0, 0.9);
        }
    }

    .burning {
        border: 2px solid rgba(255, 165, 0, 0.8);
        background-color: #9A3412;
        color: #FDE68A;
        animation: flicker 1s infinite ease-in-out;
    }

    .violent-delights-banner {
        background-color: #FFFFFF;
        color: #DC2626;
        border: 2px solid #DC2626;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    @keyframes glow {
        0%, 100% {
            box-shadow: 
                0 0 8px rgba(236, 72, 153, 0.6),
                0 0 16px rgba(255, 255, 255, 0.5);
            border-color: rgba(249, 115, 224, 0.8);
        }
        50% {
            box-shadow: 
                0 0 12px rgba(236, 72, 153, 0.9),
                0 0 24px rgba(255, 255, 255, 0.8);
            border-color: rgba(249, 115, 224, 1);
        }
    }

    .halo-effect {
        border: 2px solid rgba(249, 115, 224, 0.7);
        background-color: #be185d;
        color: #fce7f3;
        animation: glow 2s infinite ease-in-out;
    }

    @keyframes decay {
        0%, 100% {
            transform: translate(0, 0);
            opacity: 1;
            text-shadow: 0 0 2px #a3e635;
        }
        10% { transform: translate(-1px, -1px); }
        20% { transform: translate(1px, 1px); opacity: 0.9; }
        30% { transform: translate(-1px, 1px); text-shadow: 0 0 5px #a3e635; }
        40% { transform: translate(1px, -1px); opacity: 1; }
        50% { transform: translate(0, 0); text-shadow: none; }
        60% { transform: translate(-1px, 0); opacity: 0.8; }
        70% { transform: translate(1px, 0); }
        80% { transform: translate(0, -1px); text-shadow: 0 0 3px #a3e635; }
        90% { transform: translate(0, 1px); opacity: 0.9; }
    }

    .decaying {
        border: 2px solid #4d7c0f;
        background-color: #1a2e05;
        color: #d9f99d;
        animation: decay 0.5s infinite ease-in-out;
    }

    /* --- Christmas Theme Effects --- */
    @keyframes snowfall {
      0% { transform: translateY(-50px); opacity: 1; }
      100% { transform: translateY(100px); opacity: 0; }
    }

    .snowy-banner {
      background: linear-gradient(to bottom, #0f172a, #1e293b);
      color: #e0f2fe; /* Icy blue text */
      border: 2px solid #38bdf8;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
      text-shadow: 0 0 5px #38bdf8;
      overflow: hidden; /* Keep snowflakes inside */
      position: relative;
    }

    .snowflake {
      position: absolute;
      width: 3px;
      height: 3px;
      background: white;
      border-radius: 50%;
      animation-name: snowfall;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }
    
    @keyframes frost-pulse {
      0%, 100% { 
        border-color: rgba(191, 219, 254, 0.7);
        box-shadow: 0 0 5px rgba(191, 219, 254, 0.3);
      }
      50% { 
        border-color: rgba(255, 255, 255, 1);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }
    }

    .frosted {
        border: 2px solid #bfdbfe; /* Light blue */
        background-color: #1e3a8a; /* Deep blue */
        color: #eff6ff;
        text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        animation: frost-pulse 3s infinite ease-in-out;
    }

    /* --- Shadowy & Cursed Effects --- */
    @keyframes shadow-breathe {
      0%, 100% {
        box-shadow: 0 0 15px rgba(109, 40, 217, 0.4);
        border-color: rgba(139, 92, 246, 0.7);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 25px rgba(109, 40, 217, 0.7);
        border-color: rgba(167, 139, 250, 1);
        transform: scale(1.01);
      }
    }

    .cursed-banner {
      background: linear-gradient(to top, #1e1b1b, #2e1065);
      color: #e9d5ff; /* Pale purple */
      animation: shadow-breathe 4s infinite ease-in-out;
    }

    @keyframes cursed-writhe {
      0% { transform: translate(0, 0); }
      25% { transform: translate(1px, -1px); }
      50% { transform: translate(0, 1px); }
      75% { transform: translate(-1px, 0); }
      100% { transform: translate(0, 0); }
    }

    .cursed-nameplate {
        border: 2px solid #5b21b6;
        background-color: #1e1b1b;
        color: #d8b4fe;
        animation: cursed-writhe 0.3s infinite linear;
        box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
    }

    /* --- Tutorial Styles --- */
    .tutorial-title {
        font-family: 'Creepster', cursive;
    }
    .tutorial-modal-content {
        background-color: rgba(45, 55, 72, 0.95);
        backdrop-filter: blur(8px);
    }
    .nav-button {
        transition: all 0.3s ease;
    }
    .nav-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .progress-dot {
        transition: background-color 0.3s ease;
    }
  </style>
</head>
<body class="flex flex-col text-sm">

  <div class="container mx-auto p-4 flex flex-col flex-grow">

    <div id="effect-banners-container" class="w-full mb-2 flex flex-col gap-2"></div>

    <div class="bg-gray-800 p-2 rounded-lg shadow-md mb-2">
      <div id="phase-banner" class="text-center text-xl font-bold text-blue-400">PHASE, ROUND 0</div>
    </div>

    <div class="bg-gray-700 p-2 rounded-lg shadow-md flex justify-between items-center mb-2">
      <div id="timer-display" class="text-base font-semibold text-yellow-300">No timer</div>
      <div id="action-progress" class="text-base font-semibold text-green-300">Waiting for players...</div>
    </div>

    <div class="flex flex-grow gap-2 mb-2">

      <div class="w-1/4 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <h3 class="text-base font-semibold mb-2 text-center">Cards</h3>
        <div id="player-hand" class="flex flex-col flex-grow overflow-y-auto gap-2 pr-2">
          <p class="text-gray-400 text-center">No cards in hand.</p>
        </div>
      </div>

      <div class="w-1/2 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <h3 class="text-base font-semibold mb-2 text-center">Game Announcements</h3>
        <div id="announcements-area" class="flex-grow overflow-y-auto p-2 bg-gray-700 rounded-md text-gray-200"></div>
      </div>

      <div class="w-1/4 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <div id="player-list-area" class="flex-grow overflow-y-auto"></div>
      </div>

    </div>

    <div class="bg-gray-800 p-4 rounded-lg shadow-md text-center">
      <button id="action-button" class="action-button w-full disabled-button" disabled>Connecting...</button>
    </div>

  </div>

  <!-- Tutorial Modal -->
  <div id="tutorial-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
      <div class="tutorial-modal-content w-full max-w-2xl rounded-2xl shadow-2xl border border-gray-700 p-6 md:p-8 flex flex-col">
          
          <!-- Content Area -->
          <div id="tutorial-content" class="flex-grow mb-6 text-gray-300">
              <!-- Pages will be injected here by JS -->
          </div>

          <!-- Progress Indicator -->
          <div id="progress-dots" class="flex justify-center items-center mb-6 space-x-3">
              <!-- Dots will be generated by JS -->
          </div>

          <!-- Navigation -->
          <div class="flex flex-col items-center space-y-4">
              <div class="flex justify-center w-full space-x-4">
                  <button id="prev-btn" class="nav-button w-1/2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                      Previous
                  </button>
                  <button id="next-btn" class="nav-button w-1/2 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                      Next
                  </button>
              </div>
              <button id="skip-btn" class="nav-button w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                  Skip Tutorial
              </button>
          </div>
      </div>
  </div>


  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script>
    const savedPlayerId = localStorage.getItem('cultist_player_id');
    const socket = io({ auth: { player_id: savedPlayerId } });

    socket.on('initial_connect', data => {
      localStorage.setItem('cultist_player_id', data.player_id);
      playerId = data.player_id;
      console.log('Assigned playerId =', playerId);
    });

    let playerId, playerName="Guest", playerRole="Unknown", playerHand=[], playerStatusEffects={}, playerIsAlive=true, playerIsAsleep=false;
    let currentPhase="Connecting", roundNumber=0, globalStatusEffects={}, publicAnnouncements=[], alivePlayersInfo=[], deadPlayersInfo=[], eveningSubmittedCount=0, nightAsleepCount=0, morningReadyCount=0;
    let apocalypseVoteTarget=null, apocalypseVotes={}, desiredPlayersCount=0, gameSetupCompleted=false, lastPhaseStartTime=0, dawnActivePlayersCount=0, dawnCompletedActionsCount=0, cultistKillVotes={}, cultistKillTarget=null;
    let lobbyReadyCount = 0, lobbyReadyPlayers = [];
    
    let votingSubPhase = "Inactive", votingNominations = {}, nominatedSpeakers = [], currentSpeaker = null, votersReadyForExecutionCount = 0, votingFinalVotes = {};
    let duskReadyCount = 0;
    
    let previousPhase = null;

    const STATUS_UI_MAP = {
        mark_of_the_beast: { bannerText: 'MARKED BY THE BEAST', bannerClasses: 'cursed-banner', highlightClasses: 'cursed-nameplate', isPrivate: true },
        eternal_winter: { bannerText: 'ETERNAL WINTER', bannerClasses: 'snowy-banner', highlightClasses: 'frosted', isPrivate: true },
        silence: { bannerText: 'SILENCED', bannerClasses: 'bg-yellow-500 border-yellow-300', shadowStart: 'rgba(250, 204, 21, 0.4)', shadowEnd: 'rgba(250, 204, 21, 0.6)', highlightClasses: 'border-2 border-yellow-400 ring-2 ring-yellow-500' },
        delirium: { bannerText: 'DELIRIOUS', bannerClasses: 'bg-emerald-500 border-emerald-300', shadowStart: 'rgba(16, 185, 129, 0.4)', shadowEnd: 'rgba(16, 185, 129, 0.6)', highlightClasses: 'border-2 border-emerald-400 ring-2 ring-emerald-500' },
        vote_restriction: { bannerText: 'VOTING RESTRICTED', bannerClasses: 'bg-orange-600 border-orange-400', shadowStart: 'rgba(249, 115, 22, 0.4)', shadowEnd: 'rgba(249, 115, 22, 0.6)', highlightClasses: 'border-2 border-orange-500 ring-2 ring-orange-500' },
        immolated: { bannerText: 'IMMOLATED', bannerClasses: 'burning', highlightClasses: 'burning' },
        burning: { bannerText: 'BURNING', bannerClasses: 'burning', highlightClasses: 'burning' },
        violent_delights_quest: { bannerText: 'VIOLENT DELIGHTS IN PROGRESS', bannerClasses: 'violent-delights-banner', isPrivate: true },
        divine_protection: { bannerText: 'I HAVE SEEN THE LIGHT', bannerClasses: 'halo-effect', highlightClasses: 'halo-effect' },
        lazarus_effect: { bannerText: 'RESURRECTED', bannerClasses: 'decaying', highlightClasses: 'decaying', isPrivate: true },
        harbinger_active: { bannerText: 'HARBINGER OF DOOM ACTIVATED', bannerClasses: 'harbinger-effect' }
    };

    const phaseBanner = document.getElementById('phase-banner'), timerDisplay = document.getElementById('timer-display'), progressDisplay = document.getElementById('action-progress'), playerHandDiv = document.getElementById('player-hand'), announcementsArea = document.getElementById('announcements-area'), playerListArea = document.getElementById('player-list-area'), actionButton = document.getElementById('action-button'), effectBannersContainer = document.getElementById('effect-banners-container');

    socket.on('connect', () => console.log('✅ Connected'));
    socket.on('prompt_set_player_count', showSetPlayerCountDialog);
    socket.on('prompt_for_name', showNameInputDialog);
    socket.on('name_accepted', data => { 
        playerName = data.name; 
        playerId = data.player_id; 
        document.title = `CULTIST – ${playerName}`; 
        if (!localStorage.getItem('tutorial_completed')) {
            showTutorial();
        }
        updateGUI(); 
    });
    socket.on('game_state_update', data => {
      previousPhase = currentPhase;
      currentPhase = data.current_phase; 
      
      if (previousPhase !== 'Morning' && currentPhase === 'Morning') {
        playBirdChirps();
      }

      roundNumber = data.round_number; globalStatusEffects = data.global_status_effects; publicAnnouncements = data.public_announcements; alivePlayersInfo = data.alive_players; deadPlayersInfo = data.dead_players; eveningSubmittedCount = data.evening_submitted_count; nightAsleepCount = data.night_asleep_count; morningReadyCount = data.morning_ready_count; apocalypseVoteTarget = data.apocalypse_vote_target; apocalypseVotes = data.apocalypse_votes || {}; lastPhaseStartTime = data.last_phase_start_time; dawnActivePlayersCount = data.dawn_active_players_count; dawnCompletedActionsCount = data.dawn_completed_actions_count; desiredPlayersCount = data.desired_players_count; gameSetupCompleted = data.game_setup_completed; cultistKillVotes = data.cultist_kill_votes || {}; cultistKillTarget = data.cultist_kill_target;
      lobbyReadyCount = data.lobby_ready_count; lobbyReadyPlayers = data.lobby_ready_players || [];
      votingSubPhase = data.voting_sub_phase; votingNominations = data.voting_nominations || {}; nominatedSpeakers = data.nominated_speakers || []; currentSpeaker = data.current_speaker; votersReadyForExecutionCount = data.voters_ready_for_execution_count; votingFinalVotes = data.voting_final_votes || {};
      duskReadyCount = data.dusk_ready_count;
      updateGUI();
    });
    socket.on('private_player_state', data => { playerHand = data.hand; playerRole = data.role; playerStatusEffects = data.status_effects; playerIsAlive = data.is_alive; playerIsAsleep = data.is_asleep; updateGUI(); });
    socket.on('action_confirmed', data => console.log('✔️', data.message));
    socket.on('error', data => { alert(`Error: ${data.message}`); console.error(data.message); });
    socket.on('sleep_prompt', data => { announcementsArea.innerHTML += `<p class="text-yellow-300">${data.message}</p>`; announcementsArea.scrollTop = announcementsArea.scrollHeight; updateGUI(); });
    socket.on('cultist_wake_up', data => { announcementsArea.innerHTML += `<p class="text-red-300 font-bold">${data.message}</p>`; announcementsArea.scrollTop = announcementsArea.scrollHeight; updateGUI(); });
    socket.on('reveal_role', data => showRoleRevealDialog(data.role, data.objective));
    
    socket.on('private_announcement', data => {
        showPrivateMessageDialog("A Private Message", data.message);
    });

    socket.on('show_player_hand', data => {
        showRevealedHandDialog(data.player_name, data.hand);
    });

    socket.on('show_third_eye_vision', data => {
        showThirdEyeVisionDialog(data.vision);
    });

    socket.on('prompt_compulsion_initial', data => {
        showCompulsionInitialDialog(data.is_selected);
    });

    socket.on('prompt_compulsion_resolution', () => {
        showCompulsionResolutionDialog();
    });

    socket.on('prompt_harbinger_kill', () => {
        showHarbingerKillDialog();
    });
    
    socket.on('play_tolling_bell', () => {
        playTollingBell();
    });

    document.addEventListener('DOMContentLoaded', updateGUI);

    let timerId = null;

    function playBirdChirps() {
        Tone.start();
        const synth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.1 }
        }).toDestination();

        const notes = ["C5", "D5", "E5", "G5", "A5"];
        
        const now = Tone.now();
        for (let i = 0; i < 5; i++) {
            const note = notes[Math.floor(Math.random() * notes.length)];
            const time = now + i * 0.15 + Math.random() * 0.1;
            synth.triggerAttackRelease(note, "32n", time);
        }
    }

    function playTollingBell() {
        Tone.start();
        const bell = new Tone.PolySynth(Tone.MembraneSynth, {
            pitchDecay: 0.05,
            octaves: 10,
            oscillator: { type: 'sine' },
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 1.4,
                attackCurve: 'exponential'
            }
        });

        const reverb = new Tone.Reverb({
            decay: 5,
            preDelay: 0.01
        }).toDestination();
        
        bell.connect(reverb);
        
        const now = Tone.now();
        bell.triggerAttackRelease("C2", "8n", now);
        bell.triggerAttackRelease("C2", "8n", now + 0.7);
        bell.triggerAttackRelease("C2", "8n", now + 1.4);
    }

    function updateGUI(){
      effectBannersContainer.innerHTML = '';
      if (globalStatusEffects.Carnage) {
        const banner = document.createElement('div');
        banner.className = 'w-full text-center font-bold uppercase p-1 rounded-md text-white text-center bg-red-600 border-red-400 animate-pulse-flame';
        banner.style.setProperty('--shadow-color-start', '0 0 8px rgba(255, 80, 80, 0.4)');
        banner.style.setProperty('--shadow-color-end', '0 0 25px rgba(255, 80, 80, 0.7)');
        banner.textContent = 'CARNAGE IN PROGRESS';
        effectBannersContainer.appendChild(banner);
      }
      
      for (const key in globalStatusEffects) {
          const ui = STATUS_UI_MAP[key];
          if (ui && ui.bannerText) {
              const banner = document.createElement('div');
              banner.className = 'w-full text-center font-bold uppercase p-1 rounded-md';
              banner.classList.add(...ui.bannerClasses.split(' '));
              banner.textContent = ui.bannerText;
              effectBannersContainer.appendChild(banner);
          }
      }

      const bannersToShow = new Set();
      for (const key in playerStatusEffects) {
          if (STATUS_UI_MAP[key]) {
              bannersToShow.add(key);
          }
      }
      if (!playerIsAlive) {
          bannersToShow.add('silence');
      }

      bannersToShow.forEach(key => {
          const ui = STATUS_UI_MAP[key];
          if (ui && ui.bannerText) {
              const banner = document.createElement('div');
              banner.className = 'w-full text-center font-bold uppercase p-2 rounded-md';
              banner.classList.add(...ui.bannerClasses.split(' '));
              banner.textContent = ui.bannerText;

              if (key === 'eternal_winter') {
                  generateSnowflakes(banner);
              }
              
              if (ui.shadowStart) {
                banner.classList.add('animate-pulse-flame');
                banner.style.setProperty('--shadow-color-start', `0 0 8px ${ui.shadowStart}`);
                banner.style.setProperty('--shadow-color-end', `0 0 25px ${ui.shadowEnd}`);
              }
              effectBannersContainer.appendChild(banner);
          }
      });

      let phaseText = currentPhase.toUpperCase();
      if (currentPhase === 'Voting') {
        phaseText += ` - ${votingSubPhase.toUpperCase()}`;
      }
      phaseBanner.textContent = `${phaseText}, ROUND ${roundNumber}`;
      
      if(timerId) clearInterval(timerId);
      const timers = { "Evening": 30, "Voting_Nomination": 30, "Voting_Speaking": 30, "Voting_Execution": 30 };
      const timerKey = currentPhase === 'Voting' ? `${currentPhase}_${votingSubPhase}` : currentPhase;
      if (timers[timerKey]) startTimer(timers[timerKey]);
      else timerDisplay.textContent = "No timer";

      if(currentPhase === "Lobby") progressDisplay.textContent = `${lobbyReadyCount}/${desiredPlayersCount} Players Ready`;
      else if (currentPhase === 'Voting' && votingSubPhase === 'Speaking') {
        progressDisplay.textContent = currentSpeaker ? `Speaking: ${currentSpeaker}` : 'Waiting for next speaker...';
      } else {
        progressDisplay.textContent = '';
      }

      playerHandDiv.innerHTML = "";
      if(playerHand.length){
        playerHandDiv.className = 'flex flex-col flex-grow overflow-y-auto gap-2 pr-2';
        playerHand.forEach(c => {
          const cardDiv = document.createElement('div');
          cardDiv.className = 'bg-gray-700 p-3 rounded-lg shadow-md border border-gray-600 hover:border-blue-500 hover:bg-gray-600 transition duration-200 cursor-pointer flex items-center justify-center';
          cardDiv.onclick = () => showCardDetails(c);
          const cardTitle = document.createElement('h4');
          cardTitle.className = 'font-bold text-white text-sm text-center';
          cardTitle.textContent = c.name;
          cardDiv.appendChild(cardTitle);
          playerHandDiv.appendChild(cardDiv);
        });
      } else {
        playerHandDiv.className = 'flex flex-col flex-grow overflow-y-auto';
        playerHandDiv.innerHTML = `<p class="text-gray-400 text-center mt-4">No cards in hand.</p>`;
      }

      announcementsArea.innerHTML = publicAnnouncements.map(a => `<p>${a}</p>`).join('');
      announcementsArea.scrollTop = announcementsArea.scrollHeight;

      playerListArea.innerHTML = "";
      if (alivePlayersInfo.length > 0) {
        const aliveH = document.createElement('h4');
        aliveH.className = 'text-base font-semibold mb-2 text-center text-white';
        aliveH.textContent = 'Alive Players';
        playerListArea.appendChild(aliveH);
        alivePlayersInfo.forEach(p => {
            const pe = document.createElement('div');
            let classes = ['p-2', 'my-1', 'bg-gray-700', 'rounded-md', 'text-center'];
            for (const effect in p.status_effects) {
                if (STATUS_UI_MAP[effect] && STATUS_UI_MAP[effect].highlightClasses) {
                    classes.push(...STATUS_UI_MAP[effect].highlightClasses.split(' '));
                }
            }
            if (p.is_asleep) {
                classes.push(...'border-2 border-purple-400 ring-2 ring-purple-500'.split(' '));
            }
            if (currentSpeaker === p.name) {
                classes.push(...'border-4 border-cyan-400 ring-4 ring-cyan-500 animate-pulse-flame'.split(' '));
            }
            // MODIFIED: Show ready status in lobby
            if (currentPhase === 'Lobby' && lobbyReadyPlayers.includes(p.player_id)) {
                classes.push('border-2', 'border-green-400');
            }

            pe.className = classes.join(' ');
            let content = p.name;
            
            if (currentPhase === 'Voting' && votingSubPhase === 'Nomination') {
                const nominators = Object.keys(votingNominations).filter(nominator => votingNominations[nominator].includes(p.name));
                if (nominators.length > 0) content += ` <span class="text-xs text-cyan-300">(${nominators.join(', ')})</span>`;
            }
            if (playerRole === 'Cultist' && currentPhase === 'Night') {
                const voters = Object.keys(cultistKillVotes).filter(voter => cultistKillVotes[voter] === p.name);
                if (voters.length > 0) {
                    pe.style.borderColor = '#f87171';
                    content += ` <span class="text-xs text-red-300">(${voters.join(', ')})</span>`;
                }
            }
            pe.innerHTML = content;
            playerListArea.appendChild(pe);
        });
      }

      if(deadPlayersInfo.length){
        const deadH = document.createElement('h4');
        deadH.className = 'text-base font-semibold mt-4 mb-2 text-center text-white';
        deadH.textContent = 'Dead Players';
        playerListArea.appendChild(deadH);
        deadPlayersInfo.forEach(p => {
          const pe = document.createElement('div');
          pe.className = 'p-2 my-1 bg-gray-900 text-gray-500 rounded-md text-center line-through border-2 border-yellow-400 ring-2 ring-yellow-500';
          pe.textContent = p.name;
          playerListArea.appendChild(pe);
        });
      }
      updateActionButton();
    }

    function generateSnowflakes(banner) {
        const snowflakeCount = 30;
        for (let i = 0; i < snowflakeCount; i++) {
            let snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.style.left = `${Math.random() * 100}%`;
            snowflake.style.animationDuration = `${(Math.random() * 5) + 5}s`;
            snowflake.style.animationDelay = `${Math.random() * 5}s`;
            const size = Math.random() * 2 + 1;
            snowflake.style.width = `${size}px`;
            snowflake.style.height = `${size}px`;
            banner.appendChild(snowflake);
        }
    }

    function startTimer(sec){
      const start = lastPhaseStartTime;
      timerId = setInterval(() => {
        const rem = sec - ((Date.now()/1000) - start);
        if (rem >= 0) timerDisplay.textContent = `Time Left: ${Math.ceil(rem)}s`;
        else clearInterval(timerId);
      }, 1000);
    }

    function updateActionButton(){
      actionButton.disabled = true;
      actionButton.className = 'action-button w-full disabled-button';
      actionButton.textContent = "Waiting...";

      if(currentPhase === "Lobby"){
        const namedPlayers = alivePlayersInfo.filter(p => !p.name.startsWith("Guest_"));
        const amIReady = lobbyReadyPlayers.includes(playerId);

        if(!desiredPlayersCount) { 
            actionButton.textContent = "Set Player Count"; 
            actionButton.onclick = showSetPlayerCountDialog; 
            actionButton.disabled = false; 
        } else if(namedPlayers.length < desiredPlayersCount) {
            actionButton.textContent = `Waiting for ${desiredPlayersCount - namedPlayers.length} more players...`;
        } else if (amIReady) {
            actionButton.textContent = "Waiting for other players...";
        } else { 
            actionButton.textContent = "Ready to Start"; 
            actionButton.onclick = () => socket.emit('start_game_request'); 
            actionButton.disabled = false; 
        }
        if(!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        return;
      }
      if(currentPhase === "Evening" || currentPhase === "Dusk"){
        const me = alivePlayersInfo.find(p => p.player_id === playerId) || deadPlayersInfo.find(p => p.player_id === playerId);
        const hasReadied = currentPhase === "Dusk" && (me ? me.has_readied_dusk : false);
        const hasSubmitted = currentPhase === "Evening" && (me ? me.has_submitted_evening_cards : false);
        
        let disabled = false;
        if (currentPhase === "Dusk") {
            disabled = hasReadied;
        } else { // Evening logic
            const canAct = playerIsAlive || (!playerIsAlive && playerHand.length > 0);
            disabled = !canAct || hasSubmitted || (playerStatusEffects.delirium && !playerHand.some(c => c.name === 'I Saw the Light'));
        }
        
        actionButton.textContent = currentPhase === "Dusk" ? "Ready for Evening" : "Confirm Cards";
        actionButton.onclick = currentPhase === "Dusk" ? () => socket.emit('ready_for_evening') : confirmEveningCards;
        actionButton.disabled = disabled;
        
        if (!disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasReadied || hasSubmitted) actionButton.textContent = "Waiting for other players...";
        return;
      }
      if(currentPhase === "Morning") {
        const me = alivePlayersInfo.find(p => p.player_id === playerId);
        const hasReadied = me ? me.has_readied_morning : false;
        actionButton.textContent = "Proceed to Voting";
        actionButton.onclick = () => socket.emit('proceed_to_voting');
        actionButton.disabled = !playerIsAlive || hasReadied;
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasReadied) actionButton.textContent = "Waiting for others...";
        return;
      }
      if(currentPhase === "ApocalypseVote") {
        const hasVoted = apocalypseVotes[playerId];
        actionButton.textContent = `Vote on ${apocalypseVoteTarget}`;
        actionButton.onclick = showApocalypseVoteDialog;
        const am_i_target = alivePlayersInfo.find(p => p.name === apocalypseVoteTarget)?.player_id === playerId;
        actionButton.disabled = !playerIsAlive || am_i_target || hasVoted;
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasVoted) actionButton.textContent = "Waiting for other votes...";
        return;
      }
      if(currentPhase === "Night"){
        const totalPlayers = alivePlayersInfo.length + deadPlayersInfo.length;
        const allAsleep = nightAsleepCount >= totalPlayers;
        const isCultist = playerRole === "Cultist" && playerIsAlive && allAsleep;
        if (isCultist) {
            if (cultistKillTarget) {
                actionButton.textContent = `Confirm Kill: ${cultistKillTarget}`;
                actionButton.onclick = () => socket.emit('confirm_cultist_kill');
                actionButton.className = 'action-button w-full kill-ready-button';
                actionButton.disabled = false;
            } else {
                actionButton.textContent = "Vote to Kill";
                actionButton.onclick = showKillVoteDialog;
                actionButton.className = 'action-button w-full kill-vote-button';
                actionButton.disabled = false;
            }
        } else {
            actionButton.textContent = playerIsAsleep ? "Awaken" : "Sleep";
            actionButton.onclick = () => socket.emit('toggle_sleep');
            actionButton.disabled = false;
            actionButton.className = playerIsAsleep ? 'action-button w-full' : 'action-button w-full sleep-button';
        }
        if(!actionButton.disabled) actionButton.classList.remove('disabled-button');
        return;
      }
      if(currentPhase === "Voting") {
        const me = alivePlayersInfo.find(p => p.player_id === playerId);

        if ('vote_restriction' in playerStatusEffects) {
            actionButton.textContent = "Cannot Participate (Screams from the Void)";
            actionButton.disabled = true;
            actionButton.className = 'action-button w-full disabled-button';
            return;
        }

        if (votingSubPhase === 'Nomination') {
          actionButton.textContent = "Nominate a Player";
          actionButton.onclick = showNominationDialog;
          actionButton.disabled = !playerIsAlive;
        } else if (votingSubPhase === 'Speaking') {
          const isReady = me ? me.is_ready_for_execution : false;
          const allSpeakersDone = currentSpeaker === null && nominatedSpeakers.length > 0;
          actionButton.textContent = allSpeakersDone ? "Ready for Execution Vote" : "Waiting for speakers...";
          actionButton.onclick = allSpeakersDone ? () => socket.emit('ready_for_execution_vote') : null;
          actionButton.disabled = !playerIsAlive || !allSpeakersDone || isReady;
          if (isReady) actionButton.textContent = "Waiting for others...";
        } else if (votingSubPhase === 'Execution') {
          const hasVoted = me ? me.has_voted : false;
          actionButton.textContent = "Vote to Execute";
          actionButton.onclick = showExecutionVoteDialog;
          actionButton.disabled = !playerIsAlive || hasVoted;
          if (hasVoted) actionButton.textContent = "Waiting for other votes...";
        }
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
      }
    }

    function createDialog(title){
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      document.body.appendChild(overlay);
      const dialogContent = document.createElement('div');
      dialogContent.className = 'dialog-content';
      overlay.appendChild(dialogContent);
      const h2 = document.createElement('h2');
      h2.className = 'text-xl font-bold mb-4 text-center';
      h2.textContent = title;
      dialogContent.appendChild(h2);
      const dialogBody = document.createElement('div');
      dialogBody.className = 'dialog-body';
      dialogContent.appendChild(dialogBody);
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'action-button mt-4 bg-red-600 hover:bg-red-700';
      closeBtn.onclick = () => overlay.remove();
      dialogContent.appendChild(closeBtn);
      return {overlay, dialogContent, dialogBody, closeButton: closeBtn};
    }

    function showNameInputDialog(){
      const {overlay, dialogContent, dialogBody, closeButton} = createDialog("Enter Your Name");
      closeButton.remove();
      const input = document.createElement('input');
      input.type = 'text'; input.placeholder = 'Your Name'; input.className = 'w-full p-2 rounded bg-gray-700 text-white mb-4';
      dialogBody.appendChild(input);
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const btn = document.createElement('button');
      btn.textContent = 'Confirm Name'; btn.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
      btn.onclick = () => { 
        Tone.start();
        const val = input.value.trim(); 
        if(val){ 
            socket.emit('player_name_submit',{name:val}); 
            overlay.remove(); 
        } else { 
            alert("Name required."); 
        } 
      };
      buttonContainer.appendChild(btn);
      dialogContent.appendChild(buttonContainer);
      input.addEventListener('keypress', e => { if(e.key==='Enter') btn.click(); });
      input.focus();
    }

    function showSetPlayerCountDialog(){
      const {overlay, dialogContent, dialogBody, closeButton} = createDialog("Set Total Players");
      closeButton.remove();
      const input = document.createElement('input');
      input.type = 'number'; input.min = 3; input.max = 15; input.value = 3; input.className = 'w-full p-2 rounded bg-gray-700 text-white mb-4';
      dialogBody.appendChild(input);
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const btn = document.createElement('button');
      btn.textContent = 'Confirm Player Count'; btn.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
      btn.onclick = () => { const cnt = parseInt(input.value,10); if(cnt>=3 && cnt<=15){ socket.emit('set_desired_player_count',{count:cnt}); overlay.remove(); } else { alert("Must be between 3 and 15"); } };
      buttonContainer.appendChild(btn);
      dialogContent.appendChild(buttonContainer);
      input.addEventListener('keypress', e => { if(e.key==='Enter') btn.click(); });
      input.focus();
    }

    function showRoleRevealDialog(role, objective){
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Your Role & Objective");
        closeButton.remove();
        dialogBody.innerHTML = `<p class="text-xl font-bold mb-2">Role: <span class="${role==='Cultist'?'text-red-400':'text-blue-400'}">${role}</span></p><p class="mb-4">${objective}</p>`;
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        const confirm = document.createElement('button');
        confirm.textContent = 'Understood'; confirm.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
        confirm.onclick = () => { overlay.remove(); updateGUI(); };
        buttonContainer.appendChild(confirm);
        dialogContent.appendChild(buttonContainer);
    }

    function showPrivateMessageDialog(title, message) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(title);
        closeButton.textContent = 'Understood';
        dialogBody.innerHTML = `<p class="text-purple-300 font-bold italic text-center">${message}</p>`;
    }

    function showRevealedHandDialog(targetName, hand) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(`${targetName}'s Hand`);
        closeButton.textContent = 'Got it';
        if (hand.length > 0) {
            const cardList = hand.map(card => `<div class="bg-gray-700 p-2 my-1 rounded-md text-center">${card.name}</div>`).join('');
            dialogBody.innerHTML = cardList;
        } else {
            dialogBody.innerHTML = `<p class="text-gray-400 text-center">This player has no cards.</p>`;
        }
    }

    function showThirdEyeVisionDialog(vision) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Third Eye Vision");
        closeButton.textContent = 'Close Vision';
        if (vision && vision.length > 0) {
            let content = '<div class="space-y-3">';
            vision.forEach(item => {
                content += `
                    <div class="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                        <span class="font-semibold text-purple-300">${item.player_name}:</span>
                        <span class="text-gray-200">${item.card.name}</span>
                    </div>
                `;
            });
            content += '</div>';
            dialogBody.innerHTML = content;
        } else {
            dialogBody.innerHTML = `<p class="text-gray-400 text-center">Your vision reveals nothing. No other players have cards.</p>`;
        }
    }

    function showCompulsionInitialDialog(isSelected) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("A Dark Compulsion");
        closeButton.textContent = 'I understand';
        let message = `One of you has been compelled to say the word "Cultist" at least once before the next sundown. This will be on your honor. If you do not do this, you will be killed.`;
        if (isSelected) {
            message = `<strong class="text-red-400">You have been selected for compulsion.</strong><br><br>` + message;
        }
        dialogBody.innerHTML = `<p class="text-center">${message}</p>`;
    }

    function showCompulsionResolutionDialog() {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Honor's Reckoning");
        closeButton.remove();

        dialogBody.innerHTML = `<p class="text-center mb-4">Did you successfully say the word "Cultist" at least once before sundown?</p>`;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';

        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes, I am spared';
        yesButton.className = 'action-button bg-green-600 hover:bg-green-700 text-white';
        yesButton.onclick = () => {
            socket.emit('compulsion_response', { success: true });
            overlay.remove();
        };

        const noButton = document.createElement('button');
        noButton.textContent = 'No, I will die';
        noButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
        noButton.onclick = () => {
            socket.emit('compulsion_response', { success: false });
            overlay.remove();
        };

        buttonContainer.appendChild(yesButton);
        buttonContainer.appendChild(noButton);
        dialogContent.appendChild(buttonContainer);
    }

    function confirmEveningCards() {
        socket.emit('submit_evening_cards', { selected_card_ids: [], sacrifice_card_ids: [], card_targets: {} });
    }

    function showKillVoteDialog() {
        const { overlay, dialogContent, dialogBody } = createDialog("Vote to Kill");
        dialogContent.querySelectorAll('button').forEach(b => b.remove());
        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';
        const myCurrentVoteTargetName = cultistKillVotes[playerName];
        alivePlayersInfo.forEach(p => {
            if (p.name === playerName) return;
            const item = document.createElement('div');
            item.textContent = p.name;
            item.className = (p.name === myCurrentVoteTargetName) ? selectedItemStyle : baseItemStyle;
            item.onclick = () => { socket.emit('cultist_kill_vote', { target_player_name: p.name }); overlay.remove(); };
            dialogBody.appendChild(item);
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel'; cancelBtn.className = 'action-button mt-4 bg-red-600 hover:bg-red-700';
        cancelBtn.onclick = () => overlay.remove();
        dialogContent.appendChild(cancelBtn);
    }

    function showApocalypseVoteDialog() {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(`Vote to Reveal ${apocalypseVoteTarget}'s Role?`);
        closeButton.remove();
        dialogBody.innerHTML = `<p class="text-center mb-4">If the vote fails, Carnage will be triggered!</p>`;
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        dialogBody.appendChild(buttonContainer);
        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes'; yesButton.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white';
        yesButton.onclick = () => { socket.emit('apocalypse_vote_submit', { vote: 'Yes' }); overlay.remove(); };
        buttonContainer.appendChild(yesButton);
        const noButton = document.createElement('button');
        noButton.textContent = 'No'; noButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
        noButton.onclick = () => { socket.emit('apocalypse_vote_submit', { vote: 'No' }); overlay.remove(); };
        buttonContainer.appendChild(noButton);
    }
    
    function showNominationDialog() {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Nominate Players");
      let myNominations = votingNominations[playerName] || [];

      const baseStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500';
      const selectedStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer';

      function render() {
        dialogBody.innerHTML = '<p class="mb-2 text-sm text-gray-400">Select up to two players to nominate. Your nominations are public.</p>';
        alivePlayersInfo.forEach(p => {
          if (p.name === playerName) return;
          const item = document.createElement('div');
          item.textContent = p.name;
          item.className = myNominations.includes(p.name) ? selectedStyle : baseStyle;
          item.onclick = () => {
            if (myNominations.includes(p.name)) {
              myNominations = myNominations.filter(t => t !== p.name);
            } else if (myNominations.length < 2) {
              myNominations.push(p.name);
            }
            render();
          };
          dialogBody.appendChild(item);
        });
      }
      
      closeButton.remove();
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Confirm Nominations';
      confirmBtn.className = 'action-button bg-blue-600 hover:bg-blue-700';
      confirmBtn.onclick = () => {
        socket.emit('nominate_player', { targets: myNominations });
        overlay.remove();
      };
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'action-button bg-red-600 hover:bg-red-700';
      cancelBtn.onclick = () => overlay.remove();

      buttonContainer.appendChild(confirmBtn);
      buttonContainer.appendChild(cancelBtn);
      dialogContent.appendChild(buttonContainer);
      render();
    }

    function showExecutionVoteDialog() {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Vote to Execute");
      closeButton.remove();
      
      let description = "Choose one of the speakers to execute.";
      if (playerStatusEffects.extra_vote && !playerStatusEffects.vote_restriction) {
        description = "EXTRA VOTE: Your vote will count as two.";
      } else if (playerStatusEffects.extra_vote && playerStatusEffects.vote_restriction) {
        description = "EXTRA VOTE: You can vote despite being restricted.";
      }
      dialogBody.innerHTML = `<p class="mb-2 text-sm text-gray-400">${description}</p>`;
      
      nominatedSpeakers.forEach(name => {
        const item = document.createElement('div');
        item.textContent = name;
        item.className = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-red-500';
        item.onclick = () => {
          socket.emit('submit_execution_vote', { target: name });
          overlay.remove();
        };
        dialogBody.appendChild(item);
      });

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';

      const abstainBtn = document.createElement('button');
      abstainBtn.textContent = 'Abstain';
      abstainBtn.className = 'action-button bg-gray-500 hover:bg-gray-600';
      abstainBtn.onclick = () => {
        socket.emit('abstain_execution_vote');
        overlay.remove();
      };

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'action-button bg-red-600 hover:bg-red-700';
      cancelBtn.onclick = () => overlay.remove();

      buttonContainer.appendChild(abstainBtn);
      buttonContainer.appendChild(cancelBtn);
      dialogContent.appendChild(buttonContainer);
    }

    function showCardDetails(card) {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog(card.name);
      closeButton.remove();
      dialogBody.innerHTML = `<p class="mb-4 text-gray-300"><em>${card.description}</em></p><div class="text-sm"><p><strong class="font-semibold text-gray-100">Playable In:</strong> ${card.phase_restriction.join(', ')}</p><p><strong class="font-semibold text-gray-100">Sacrifice Cost:</strong> ${card.sacrifice_cards} card(s)</p></div>`;
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const playButton = document.createElement('button');
      playButton.textContent = 'Play Card';
      playButton.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white';
      playButton.onclick = () => { initiateCardPlay(card, { overlay, dialogContent, dialogBody }); };
      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
      cancelButton.onclick = () => overlay.remove();

      const canPlayInPhase = card.phase_restriction.includes(currentPhase) || card.phase_restriction.includes("Any");
      const isDelirious = 'delirium' in playerStatusEffects;
      let canPlay = false;

      if (card.name === 'Feed the Maggots' || card.name === 'Lazarus') {
          if (!playerIsAlive) {
              canPlay = true;
          } else {
              playButton.textContent = 'Can Only Play When Dead';
          }
      } else if (isDelirious && card.name !== 'I Saw the Light') {
          playButton.textContent = 'Cannot Play (Delirious)';
      } else if (!canPlayInPhase) {
          playButton.textContent = 'Cannot Play Now';
      } else {
          if (playerIsAlive && !card.dead_card) {
              canPlay = true;
          }
          else if (!playerIsAlive && card.dead_card) {
              canPlay = true;
          }
      }
      
      if (!canPlay) {
          playButton.disabled = true;
          playButton.className = 'action-button disabled-button';
      }

      buttonContainer.appendChild(playButton);
      buttonContainer.appendChild(cancelButton);
      dialogContent.appendChild(buttonContainer);
    }

    function initiateCardPlay(card, dialogElements) {
      if (card.name === 'Feed the Maggots' || card.name === 'Lazarus') {
          socket.emit('play_special_card', { card_id: card.id });
          dialogElements.overlay.remove();
          return;
      }

      const targetTypes = ["other_player", "two_players", "dead_player", "self", "other"];
      if (targetTypes.includes(card.target_type)) {
          promptForPlayerTarget(card, dialogElements);
      } else {
          dialogElements.overlay.remove();
          let eventName;
          if (currentPhase === 'Evening' || currentPhase === 'Dusk') eventName = 'submit_evening_cards';
          else if (currentPhase === 'Voting') eventName = 'play_voting_card';
          else eventName = 'play_any_phase_card'; 
          socket.emit(eventName, { selected_card_ids: [card.id], sacrifice_card_ids: [], card_targets: {} });
      }
    }

    function promptForPlayerTarget(card, dialogElements) {
        let selectedTargets = [];
        let selectedSacrifices = []; // MODIFIED: Will now store full card objects
        const { overlay, dialogContent, dialogBody } = dialogElements;
        dialogContent.querySelector('h2').textContent = `Play: ${card.name}`;
        dialogContent.querySelectorAll('button').forEach(b => b.remove());
        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';

        function render() {
            dialogBody.innerHTML = ''; 
            
            if (card.target_type !== 'self' && card.target_type !== 'other') {
                const numTargets = card.target_type === 'two_players' ? 2 : 1;
                const targetList = card.target_type === 'dead_player' ? deadPlayersInfo : alivePlayersInfo;
                const targetHeader = document.createElement('h4');
                targetHeader.className = 'font-bold mb-2';
                targetHeader.textContent = `Select ${numTargets} Target Player(s):`;
                dialogBody.appendChild(targetHeader);
                
                const fullTargetList = [...targetList];
                if (card.target_type === 'other_player') {
                    const self = alivePlayersInfo.find(p => p.player_id === playerId) || deadPlayersInfo.find(p => p.player_id === playerId);
                    if(self) fullTargetList.push(self);
                }

                [...new Map(fullTargetList.map(item => [item['player_id'], item])).values()].forEach(p => {
                    if (card.target_type === 'other_player' && p.player_id === playerId && card.name !== 'I Saw the Light') return;
                    const item = document.createElement('div');
                    item.textContent = p.name;
                    item.className = selectedTargets.includes(p.name) ? selectedItemStyle : baseItemStyle;
                    item.onclick = () => {
                        if (selectedTargets.includes(p.name)) {
                            selectedTargets = selectedTargets.filter(t => t !== p.name);
                        } else {
                            if (selectedTargets.length < numTargets) selectedTargets.push(p.name);
                            else if (numTargets === 1) selectedTargets = [p.name];
                        }
                        render();
                    };
                    dialogBody.appendChild(item);
                });
            } else if (card.target_type === 'self') {
                selectedTargets = [playerName];
            }

            if (card.sacrifice_cards > 0) {
                const sacrificeHeader = document.createElement('h4');
                sacrificeHeader.className = 'font-bold mt-4 mb-2';
                sacrificeHeader.textContent = `Select ${card.sacrifice_cards} Card(s) to Sacrifice:`;
                dialogBody.appendChild(sacrificeHeader);

                const availableForSacrifice = playerHand.filter(c => c.id !== card.id);

                if (availableForSacrifice.length < card.sacrifice_cards) {
                     const errorMsg = document.createElement('p');
                     errorMsg.className = 'text-red-400 text-sm';
                     errorMsg.textContent = 'Not enough cards in hand to sacrifice.';
                     dialogBody.appendChild(errorMsg);
                }
                
                selectedSacrifices.forEach(c => {
                    const item = document.createElement('div');
                    item.textContent = c.name;
                    item.className = selectedItemStyle;
                    item.onclick = () => {
                        selectedSacrifices = selectedSacrifices.filter(s => s.id !== c.id);
                        render();
                    };
                    dialogBody.appendChild(item);
                });

                availableForSacrifice.forEach(c => {
                    if (!selectedSacrifices.find(s => s.id === c.id)) {
                        const item = document.createElement('div');
                        item.textContent = c.name;
                        item.className = baseItemStyle;
                        item.onclick = () => {
                            if (selectedSacrifices.length < card.sacrifice_cards) {
                                selectedSacrifices.push(c);
                            }
                            render();
                        };
                        dialogBody.appendChild(item);
                    }
                });
            }

            const numTargetsRequired = (card.target_type === 'self' || card.target_type === 'none' || card.target_type === 'other') ? 0 : (card.target_type === 'two_players' ? 2 : 1);
            const targetsMet = selectedTargets.length === numTargetsRequired || (card.target_type === 'self') || (card.target_type === 'other');
            const sacrificesMet = selectedSacrifices.length === card.sacrifice_cards;
            const canConfirm = targetsMet && sacrificesMet;

            if (!dialogContent.querySelector('.action-button')) {
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'mt-6 flex flex-col gap-3';
                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Confirm Play';
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
                cancelButton.onclick = () => overlay.remove();
                buttonContainer.appendChild(confirmButton);
                buttonContainer.appendChild(cancelButton);
                dialogContent.appendChild(buttonContainer);
            }
            const confirmButton = dialogContent.querySelector('button:not(.bg-red-600)');
            confirmButton.disabled = !canConfirm;
            confirmButton.className = canConfirm ? 'action-button bg-blue-600 hover:bg-blue-700 text-white' : 'action-button disabled-button';
            confirmButton.onclick = () => {
                if (!canConfirm) return;
                let eventName;
                if (currentPhase === 'Evening' || currentPhase === 'Dusk') eventName = 'submit_evening_cards';
                else if (currentPhase === 'Voting') eventName = 'play_voting_card';
                else eventName = 'play_any_phase_card';
                
                socket.emit(eventName, { 
                    selected_card_ids: [card.id], 
                    sacrifice_card_ids: selectedSacrifices.map(c => c.id), 
                    card_targets: { [card.id]: selectedTargets } 
                });
                overlay.remove();
            };
        }
        render();
    }

    // --- Tutorial Logic ---
    function showTutorial() {
        const tutorialModal = document.getElementById('tutorial-modal');
        tutorialModal.classList.remove('hidden');

        const tutorialPages = [
            {
                title: "WELCOME TO CULTISTS!",
                content: "This is a work in progress so there may be bugs.<br><br>This is a game of social deduction, deception, and survival. You are either a humble <strong>Villager</strong> trying to root out evil, or a devout <strong>Cultist</strong> working to kill the non-believers."
            },
            {
                title: "ROLES",
                content: "Start the game with two cards as either a <strong>Cultist</strong> or a <strong>Villager</strong>.<br><br>As a <strong>Villager</strong>, your objective is eliminate all of the <strong>Cultists</strong>!<br><br>As a <strong>Cultist</strong>, your objective is to kill all of the <strong>Villagers</strong>!<br><br>After you are killed, you will become <strong>Dead</strong>. You will lose your cards (except for <strong>Feed the Maggots</strong> and <strong>Resurrection</strong>) and receive new cards to influence the game. You cannot speak, gesture, or vote, but you can still influence the game and lead your side to victory!"
            },
            {
                title: "POINTS",
                content: "<strong>CULTISTS!</strong> is played in multiple games, with each game lasting about 20 minutes. You will earn points each game depending on your performance.<br><br>Regardless of whether you are dead or alive, if your side wins by the end of the game, you will earn 2 points.<br><br>At the start of the game if you are a Villager, you may sign a <strong>Contract</strong> with the Dark God. If you sign your <strong>Contract</strong> and complete it, you will earn 1 extra points. If you fail your <strong>Contract</strong>, you will lose 1 point.<br><br>But be careful, Cultists! Among you may be an <strong>Enlightened Cultist</strong>. Their objective is different — their goal is to be the only living Cultist. If they are the only Cultist left, this will be announced by the Dark God. If they survive until the following Morning, they will automatically win the game.<br><br>If the <strong>Enlightened Cultist</strong> wins, they will earn 4 points. Neither the Cultists nor the Villagers will win."
            },
            {
                title: "GAMEPLAY",
                content: "Each round consist of five phases: <strong>Morning</strong>, <strong>Voting</strong>, <strong>Dusk</strong>, <strong>Evening</strong>, and <strong>Night</strong>.<br><br>During the <strong>Morning</strong>, you will learn who was killed the previous <strong>Night</strong> and hear any announcements. You will also have time to discuss and debate.<br><br>During <strong>Voting</strong>, you will nominate up to two players who you think are guilty. Each player with at least two nominations will have 30 seconds to plead their case, then you will have 30 seconds to vote on whether to execute one of the nominated players.<br><br>During <strong>Dusk</strong>, you will have the opportunity to play any cards relevant to voting.<br><br>During <strong>Evening</strong>, you will have 45 seconds to play cards from your hand.<br><br>During <strong>Night</strong>, everyone will close their eyes and the Cultists will awaken to vote on who to kill.<br><br>Most cards can only be played during specific phases. This information is included on each card."
            },
            {
                title: "CARDS",
                content: "You will start the game with two cards and receive a new card every Morning.<br><br>Playing cards allow you to sabotage your opponents, learn new information, and protect yourself from attacks! Information about each card can be viewed by tapping it.<br><br>Many cards will have a cost and require you to sacrifice other cards in order to play them.<br><br>Most cards are played during Evening.<br><br>Some cards will cause temporary effects. For example, if <strong>Silence</strong> is played against you, you will see a yellow banner and your nameplate will be highlighted in yellow, which is visible to all players. While the banner is present, you may not speak or gesture. However, you can still play cards and vote."
            }
        ];

        let currentPage = 0;
        const totalPages = tutorialPages.length;
        const contentContainer = document.getElementById('tutorial-content');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const skipBtn = document.getElementById('skip-btn');
        const progressDotsContainer = document.getElementById('progress-dots');
        progressDotsContainer.innerHTML = ''; // Clear any previous dots

        for (let i = 0; i < totalPages; i++) {
            const dot = document.createElement('div');
            dot.classList.add('w-3', 'h-3', 'rounded-full', 'bg-gray-600', 'progress-dot');
            progressDotsContainer.appendChild(dot);
        }
        const progressDots = progressDotsContainer.children;

        function showPage(pageIndex) {
            const page = tutorialPages[pageIndex];
            contentContainer.innerHTML = `
                <h2 class="tutorial-title text-5xl md:text-6xl font-bold text-purple-400 text-center mb-4">${page.title}</h2>
                <p class="text-base md:text-lg leading-relaxed text-center">${page.content}</p>
            `;
            updateNavigation();
        }

        function updateNavigation() {
            prevBtn.disabled = currentPage === 0;
            if (currentPage === totalPages - 1) {
                nextBtn.textContent = "Finish";
            } else {
                nextBtn.textContent = "Next";
            }

            for (let i = 0; i < progressDots.length; i++) {
                if (i === currentPage) {
                    progressDots[i].classList.remove('bg-gray-600');
                    progressDots[i].classList.add('bg-purple-400');
                } else {
                    progressDots[i].classList.remove('bg-purple-400');
                    progressDots[i].classList.add('bg-gray-600');
                }
            }
        }

        function closeModal() {
            tutorialModal.classList.add('hidden');
            localStorage.setItem('tutorial_completed', 'true');
        }

        prevBtn.onclick = () => {
            if (currentPage > 0) {
                currentPage--;
                showPage(currentPage);
            }
        };

        nextBtn.onclick = () => {
            if (currentPage < totalPages - 1) {
                currentPage++;
                showPage(currentPage);
            } else {
                closeModal();
            }
        };

        skipBtn.onclick = closeModal;
        
        showPage(currentPage);
    }
  </script>
</body>
</html>
