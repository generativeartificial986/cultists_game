<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>CULTISTS!</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Creepster&display=swap" rel="stylesheet">
  <style>
    body { font-family:'Special Elite', monospace; background:#1a202c; color:#e2e8f0; display:flex; flex-direction:column; min-height:100vh; }
    .container { max-width:1200px; margin:auto; padding:1rem; flex-grow:1; }
    .action-button { @apply w-full font-bold py-3 px-6 rounded-lg shadow-lg transition duration-200 ease-in-out; }
    .dialog-overlay { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); display:flex; justify-content:center; align-items:center; z-index:1000; }
    .dialog-content { background:#2d3748; padding:1.5rem; border-radius:.5rem; box-shadow:0 10px 15px rgba(0,0,0,0.3); max-width:90%; width: 500px; max-height:90%; overflow-y:auto; color:#e2e8f0; }
    .disabled-button { @apply bg-gray-500 text-gray-300 cursor-not-allowed; }
    
    #action-button.sleep-button { background:#8b5cf6; } 
    #action-button.sleep-button:hover { background:#7c3aed; }
    #action-button.kill-ready-button, #action-button.kill-vote-button { background:#b91c1c; }
    #action-button.kill-ready-button:hover, #action-button.kill-vote-button:hover { background:#991b1b; }
    
    @keyframes pulse-flame {
      0%, 100% { 
        transform: scale(1);
        box-shadow: var(--shadow-color-start); 
      }
      50% { 
        transform: scale(1.02);
        box-shadow: var(--shadow-color-end); 
      }
    }

    .animate-pulse-flame {
      animation: pulse-flame 1.5s infinite ease-in-out;
    }

    @keyframes flicker {
        0%, 100% {
            box-shadow: 
                0 0 5px rgba(255, 165, 0, 0.8),
                0 0 10px rgba(255, 165, 0, 0.6),
                0 0 15px rgba(255, 69, 0, 0.5),
                0 0 20px rgba(255, 0, 0, 0.4);
            border-color: rgba(255, 165, 0, 0.9);
            text-shadow: 0 0 3px rgba(255, 165, 0, 0.7);
        }
        50% {
            box-shadow: 
                0 0 8px rgba(255, 200, 0, 0.9),
                0 0 16px rgba(255, 165, 0, 0.8),
                0 0 24px rgba(255, 69, 0, 0.7),
                0 0 32px rgba(255, 0, 0, 0.5);
            border-color: rgba(255, 200, 0, 1);
            text-shadow: 0 0 5px rgba(255, 200, 0, 0.9);
        }
    }

    .burning {
        border: 2px solid rgba(255, 165, 0, 0.8);
        background-color: #9A3412;
        color: #FDE68A;
        animation: flicker 1s infinite ease-in-out;
    }

    .violent-delights-banner {
        background-color: #FFFFFF;
        color: #DC2626;
        border: 2px solid #DC2626;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    @keyframes glow {
        0%, 100% {
            box-shadow: 
                0 0 8px rgba(236, 72, 153, 0.6),
                0 0 16px rgba(255, 255, 255, 0.5);
            border-color: rgba(249, 115, 224, 0.8);
        }
        50% {
            box-shadow: 
                0 0 12px rgba(236, 72, 153, 0.9),
                0 0 24px rgba(255, 255, 255, 0.8);
            border-color: rgba(249, 115, 224, 1);
        }
    }

    .halo-effect {
        border: 2px solid rgba(249, 115, 224, 0.7);
        background-color: #be185d;
        color: #fce7f3;
        animation: glow 2s infinite ease-in-out;
    }

    @keyframes decay {
        0%, 100% {
            transform: translate(0, 0);
            opacity: 1;
            text-shadow: 0 0 2px #a3e635;
        }
        10% { transform: translate(-1px, -1px); }
        20% { transform: translate(1px, 1px); opacity: 0.9; }
        30% { transform: translate(-1px, 1px); text-shadow: 0 0 5px #a3e635; }
        40% { transform: translate(1px, -1px); opacity: 1; }
        50% { transform: translate(0, 0); text-shadow: none; }
        60% { transform: translate(-1px, 0); opacity: 0.8; }
        70% { transform: translate(1px, 0); }
        80% { transform: translate(0, -1px); text-shadow: 0 0 3px #a3e635; }
        90% { transform: translate(0, 1px); opacity: 0.9; }
    }

    .decaying {
        border: 2px solid #4d7c0f;
        background-color: #1a2e05;
        color: #d9f99d;
        animation: decay 0.5s infinite ease-in-out;
    }

    /* --- Christmas Theme Effects --- */
    @keyframes snowfall {
      0% { transform: translateY(-50px); opacity: 1; }
      100% { transform: translateY(100px); opacity: 0; }
    }

    .snowy-banner {
      background: linear-gradient(to bottom, #0f172a, #1e293b);
      color: #e0f2fe; /* Icy blue text */
      border: 2px solid #38bdf8;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
      text-shadow: 0 0 5px #38bdf8;
      overflow: hidden; /* Keep snowflakes inside */
      position: relative;
    }

    .snowflake {
      position: absolute;
      width: 3px;
      height: 3px;
      background: white;
      border-radius: 50%;
      animation-name: snowfall;
      animation-timing-function: linear;
      animation-iteration-count: infinite;
    }
    
    @keyframes frost-pulse {
      0%, 100% { 
        border-color: rgba(191, 219, 254, 0.7);
        box-shadow: 0 0 5px rgba(191, 219, 254, 0.3);
      }
      50% { 
        border-color: rgba(255, 255, 255, 1);
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      }
    }

    .frosted {
        border: 2px solid #bfdbfe; /* Light blue */
        background-color: #1e3a8a; /* Deep blue */
        color: #eff6ff;
        text-shadow: 0 0 3px rgba(255, 255, 255, 0.5);
        animation: frost-pulse 3s infinite ease-in-out;
    }

    /* --- Shadowy & Cursed Effects --- */
    @keyframes shadow-breathe {
      0%, 100% {
        box-shadow: 0 0 15px rgba(109, 40, 217, 0.4);
        border-color: rgba(139, 92, 246, 0.7);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 25px rgba(109, 40, 217, 0.7);
        border-color: rgba(167, 139, 250, 1);
        transform: scale(1.01);
      }
    }

    .cursed-banner {
      background: linear-gradient(to top, #1e1b1b, #2e1065);
      color: #e9d5ff; /* Pale purple */
      animation: shadow-breathe 4s infinite ease-in-out;
    }

    @keyframes cursed-writhe {
      0% { transform: translate(0, 0); }
      25% { transform: translate(1px, -1px); }
      50% { transform: translate(0, 1px); }
      75% { transform: translate(-1px, 0); }
      100% { transform: translate(0, 0); }
    }

    .cursed-nameplate {
        border: 2px solid #5b21b6;
        background-color: #1e1b1b;
        color: #d8b4fe;
        animation: cursed-writhe 0.3s infinite linear;
        box-shadow: 0 0 8px rgba(139, 92, 246, 0.5);
    }

    /* --- Tutorial Styles --- */
    .tutorial-title {
        font-family: 'Creepster', cursive;
    }
    .tutorial-modal-content {
        background-color: rgba(45, 55, 72, 0.95);
        backdrop-filter: blur(8px);
    }
    .nav-button {
        transition: all 0.3s ease;
    }
    .nav-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }
    .progress-dot {
        transition: background-color 0.3s ease;
    }
    /* --- START: ADD NEW CSS FOR HAND OF GLORY --- */
    @keyframes warm-flicker {
        0%, 100% {
            box-shadow: 
                0 0 6px rgba(252, 211, 77, 0.7), /* amber-300 */
                0 0 12px rgba(245, 158, 11, 0.5), /* amber-500 */
                0 0 20px rgba(180, 83, 9, 0.4);   /* amber-700 */
            border-color: rgba(252, 211, 77, 0.9);
            text-shadow: 0 0 2px rgba(253, 230, 138, 0.6); /* amber-200 */
        }
        50% {
            box-shadow: 
                0 0 10px rgba(253, 230, 138, 0.8), /* amber-200 */
                0 0 20px rgba(252, 211, 77, 0.7), /* amber-300 */
                0 0 30px rgba(217, 119, 6, 0.5);  /* amber-600 */
            border-color: rgba(253, 230, 138, 1);
            text-shadow: 0 0 4px rgba(253, 230, 138, 0.8);
        }
    }
    .hand-of-glory-banner {
        background-color: #78350f; /* amber-900 */
        color: #fef3c7; /* amber-100 */
        border: 2px solid #f59e0b; /* amber-500 */
        animation: warm-flicker 1.8s infinite ease-in-out;
    }
    /* --- END: ADD NEW CSS FOR HAND OF GLORY --- */
    /* --- START: NEW TOOLTIP STYLES --- */
    
    /* 1. This is the container that holds the stack of tooltips */
    #status-tooltip-container {
      display: none; /* Hidden by default */
      position: absolute; 
      z-index: 2000;
      pointer-events: none; /* Prevents tooltip from blocking mouseup */
      
      /* Stacks the mini-banners vertically */
      display: flex;
      flex-direction: column;
      gap: 4px; /* Adds a small space between banners */
    }
    
    /* 2. This is the base style for each individual mini-banner */
    .status-tooltip-item {
      padding: 0.25rem 0.75rem; /* p-1 px-3 */
      border-radius: 0.25rem; /* rounded-sm */
      font-family: 'Special Elite', monospace;
      font-size: 0.8rem; /* A bit smaller */
      font-weight: bold;
      text-transform: uppercase;
      white-space: nowrap;
      border: 2px solid transparent; /* default border */
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
      text-align: center;
    }

    /* 3. We copy ALL your existing banner keyframes and classes */
    
    /* Copied from .burning */
    /* (Keyframes 'flicker' are already defined above) */
    .burning {
        border: 2px solid rgba(255, 165, 0, 0.8);
        background-color: #9A3412;
        color: #FDE68A;
        animation: flicker 1s infinite ease-in-out;
    }
    
    /* Copied from .cursed-banner */
    /* (Keyframes 'shadow-breathe' are already defined above) */
    .cursed-banner {
      background: linear-gradient(to top, #1e1b1b, #2e1065);
      color: #e9d5ff;
      animation: shadow-breathe 4s infinite ease-in-out;
    }
    
    /* Copied from .hand-of-glory-banner */
    /* (Keyframes 'warm-flicker' are already defined above) */
    .hand-of-glory-banner {
        background-color: #78350f;
        color: #fef3c7;
        border: 2px solid #f59e0b;
        animation: warm-flicker 1.8s infinite ease-in-out;
    }
    
    /* Copied from .snowy-banner */
    .snowy-banner {
      background: linear-gradient(to bottom, #0f172a, #1e293b);
      color: #e0f2fe;
      border: 2px solid #38bdf8;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.5);
      text-shadow: 0 0 5px #38bdf8;
    }
    
    /* Copied from .violent-delights-banner */
    .violent-delights-banner {
        background-color: #FFFFFF;
        color: #DC2626;
        border: 2px solid #DC2626;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    /* Copied from .halo-effect */
    /* (Keyframes 'glow' are already defined above) */
    .halo-effect {
        border: 2px solid rgba(249, 115, 224, 0.7);
        background-color: #be185d;
        color: #fce7f3;
        animation: glow 2s infinite ease-in-out;
    }
    
    /* Copied from .decaying */
    /* (Keyframes 'decay' are already defined above) */
    .decaying {
        border: 2px solid #4d7c0f;
        background-color: #1a2e05;
        color: #d9f99d;
        animation: decay 0.5s infinite ease-in-out;
    }
    
    /* 4. We add simple styles for effects that don't have banners */
    @keyframes pulse-simple { 50% { opacity: 0.8; } }
    
    .tooltip-harbinger {
        background: #111827;
        border-color: #ef4444;
        color: #fca5a5;
        animation: pulse-simple 1.5s infinite ease-in-out;
    }
    .tooltip-silence {
        background: #fef08a; /* bg-yellow-500 */
        border-color: #fef08a; /* border-yellow-300 */
        color: #422006;
    }
    .tooltip-delirium {
        background: #10b981; /* bg-emerald-500 */
        border-color: #a7f3d0; /* border-emerald-300 */
        color: #064e3b;
    }
    .tooltip-vote_restriction {
        background: #ea580c; /* bg-orange-600 */
        border-color: #fdba74; /* border-orange-400 */
        color: #431407;
    }
    /* --- END: NEW TOOLTIP STYLES --- */
  </style>
</head>
<body class="flex flex-col text-sm">
  <!-- --- START: ADD TOOLTIP CONTAINER --- -->
  <!-- This is the hidden tooltip element. JS will show/move it. -->
  <div id="status-tooltip-container"></div>
  <!-- --- END: ADD TOOLTIP CONTAINER --- -->

  <div class="container mx-auto p-4 flex flex-col flex-grow">

    <div id="effect-banners-container" class="w-full mb-2 flex flex-col gap-2"></div>

    <div class="bg-gray-800 p-2 rounded-lg shadow-md mb-2">
      <div id="phase-banner" class="text-center text-xl font-bold text-blue-400">PHASE, ROUND 0</div>
    </div>

    <div class="bg-gray-700 p-2 rounded-lg shadow-md flex justify-between items-center mb-2">
      <div id="timer-display" class="text-base font-semibold text-yellow-300">No timer</div>
      <div id="action-progress" class="text-base font-semibold text-green-300">Waiting for players...</div>
    </div>

    <div class="flex flex-grow gap-2 mb-2">

      <div class="w-1/4 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <h3 class="text-base font-semibold mb-2 text-center">Cards</h3>
        <div id="player-hand" class="flex flex-col flex-grow overflow-y-auto gap-2 pr-2">
          <p class="text-gray-400 text-center">No cards in hand.</p>
        </div>
      </div>

      <div class="w-1/2 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <h3 class="text-base font-semibold mb-2 text-center">Game Announcements</h3>
        <div id="announcements-area" class="flex-grow overflow-y-auto p-2 bg-gray-700 rounded-md text-gray-200"></div>
      </div>

      <div class="w-1/4 bg-gray-800 p-3 rounded-lg shadow-md flex flex-col">
        <div id="player-list-area" class="flex-grow overflow-y-auto"></div>
      </div>

    </div>

    <div class="bg-gray-800 p-4 rounded-lg shadow-md text-center">
      <button id="action-button" class="action-button w-full disabled-button" disabled>Connecting...</button>
<button id="global-reset-button" class="action-button w-full bg-red-800 hover:bg-red-700 text-white mt-4">
        RESET GAME
      </button>
      </div>

  </div>
  <div id="tutorial-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50">
      <div class="tutorial-modal-content w-full max-w-2xl rounded-2xl shadow-2xl border border-gray-700 p-6 md:p-8 flex flex-col">
          
          <div id="tutorial-content" class="flex-grow mb-6 text-gray-300">
              </div>

          <div id="progress-dots" class="flex justify-center items-center mb-6 space-x-3">
              </div>

          <div class="flex flex-col items-center space-y-4">
              <div class="flex justify-center w-full space-x-4">
                  <button id="prev-btn" class="nav-button w-1/2 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                      Previous
                  </button>
                  <button id="next-btn" class="nav-button w-1/2 bg-purple-600 hover:bg-purple-500 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                      Next
                  </button>
              </div>
              <button id="skip-btn" class="nav-button w-full bg-gray-700 hover:bg-gray-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg">
                  Skip Tutorial
              </button>
          </div>
      </div>
  </div>


  <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
  <script>
    const savedPlayerId = localStorage.getItem('cultist_player_id');
    const socket = io({ auth: { player_id: savedPlayerId } });

    socket.on('initial_connect', data => {
      localStorage.setItem('cultist_player_id', data.player_id);
      playerId = data.player_id;
      console.log('Assigned playerId =', playerId);
    });

    let playerId, playerName="Guest", playerRole="Unknown", playerHand=[], playerStatusEffects={}, playerIsAlive=true, playerIsAsleep=false;
    let currentPhase="Connecting", roundNumber=0, globalStatusEffects={}, publicAnnouncements=[], alivePlayersInfo=[], deadPlayersInfo=[], eveningSubmittedCount=0, nightAsleepCount=0, morningReadyCount=0;
    let apocalypseVoteTarget=null, apocalypseVotes={}, desiredPlayersCount=0, gameSetupCompleted=false, lastPhaseStartTime=0, dawnActivePlayersCount=0, dawnCompletedActionsCount=0, cultistKillVotes={}, cultistKillTarget=null;
    let lobbyReadyCount = 0, lobbyReadyPlayers = [];
    
    let votingSubPhase = "Inactive", votingNominations = {}, nominatedSpeakers = [], currentSpeaker = null, votersReadyForExecutionCount = 0, votingFinalVotes = {};
    let duskReadyCount = 0;
    
    let previousPhase = null;

    const STATUS_UI_MAP = {
        doppelganger_pending: { bannerText: 'DOPPELGÄNGER ACTIVE', bannerClasses: 'cursed-banner', isPrivate: true },
        mark_of_the_beast: { bannerText: 'MARKED BY THE BEAST', bannerClasses: 'cursed-banner', highlightClasses: 'cursed-nameplate', isPrivate: true },
        hand_of_glory_protection: { 
            bannerText: 'HAND OF GLORY ACTIVE', 
            bannerClasses: 'hand-of-glory-banner', 
            isPrivate: true // This keeps it secret, so only the player sees it
        },
        eternal_winter: { bannerText: 'SING BABY SING', bannerClasses: 'snowy-banner', highlightClasses: 'frosted' },
        silence: { bannerText: 'SILENCED', bannerClasses: 'bg-yellow-500 border-yellow-300', shadowStart: 'rgba(250, 204, 21, 0.4)', shadowEnd: 'rgba(250, 204, 21, 0.6)', highlightClasses: 'border-2 border-yellow-400 ring-2 ring-yellow-500' },
        delirium: { bannerText: 'DELIRIOUS', bannerClasses: 'bg-emerald-500 border-emerald-300', shadowStart: 'rgba(16, 185, 129, 0.4)', shadowEnd: 'rgba(16, 185, 129, 0.6)', highlightClasses: 'border-2 border-emerald-400 ring-2 ring-emerald-500' },
        vote_restriction: { bannerText: 'VOTING RESTRICTED', bannerClasses: 'bg-orange-600 border-orange-400', shadowStart: 'rgba(249, 115, 22, 0.4)', shadowEnd: 'rgba(249, 115, 22, 0.6)', highlightClasses: 'border-2 border-orange-500 ring-2 ring-orange-500' },
        immolated: { bannerText: 'IMMOLATED', bannerClasses: 'burning', highlightClasses: 'burning' },
        burning: { bannerText: 'BURNING', bannerClasses: 'burning', highlightClasses: 'burning' },
        violent_delights_quest: { bannerText: 'VIOLENT DELIGHTS IN PROGRESS', bannerClasses: 'violent-delights-banner', isPrivate: true },
        divine_protection: { bannerText: 'I HAVE SEEN THE LIGHT', bannerClasses: 'halo-effect', highlightClasses: 'halo-effect' },
        lazarus_effect: { bannerText: 'RESURRECTED', bannerClasses: 'decaying', highlightClasses: 'decaying', isPrivate: true },
        harbinger_quest: { bannerText: 'HARBINGER OF DOOM ACTIVE', bannerClasses: 'bg-gray-900 border-red-500 text-red-300 animate-pulse', isPrivate: false }
    };

    const phaseBanner = document.getElementById('phase-banner'), timerDisplay = document.getElementById('timer-display'), progressDisplay = document.getElementById('action-progress'), playerHandDiv = document.getElementById('player-hand'), announcementsArea = document.getElementById('announcements-area'), playerListArea = document.getElementById('player-list-area'), actionButton = document.getElementById('action-button'), effectBannersContainer = document.getElementById('effect-banners-container');

    socket.on('connect', () => console.log('✅ Connected'));
    socket.on('prompt_set_player_count', showSetPlayerCountDialog);
    socket.on('prompt_for_name', showNameInputDialog);
    socket.on('name_accepted', data => { 
        playerName = data.name; 
        playerId = data.player_id; 
        document.title = `CULTIST – ${playerName}`; 
        showTutorial();
        updateGUI(); 
    });
    socket.on('game_state_update', data => {
      previousPhase = currentPhase;
      currentPhase = data.current_phase; 
      
      if (previousPhase !== 'Morning' && currentPhase === 'Morning') {
        setTimeout(playBirdChirps, 4000); // 3000 milliseconds = 3 seconds
      }

      roundNumber = data.round_number; globalStatusEffects = data.global_status_effects; publicAnnouncements = data.public_announcements; alivePlayersInfo = data.alive_players; deadPlayersInfo = data.dead_players; eveningSubmittedCount = data.evening_submitted_count; nightAsleepCount = data.night_asleep_count; morningReadyCount = data.morning_ready_count; apocalypseVoteTarget = data.apocalypse_vote_target; apocalypseVotes = data.apocalypse_votes || {}; lastPhaseStartTime = data.last_phase_start_time; dawnActivePlayersCount = data.dawn_active_players_count; dawnCompletedActionsCount = data.dawn_completed_actions_count; desiredPlayersCount = data.desired_players_count; gameSetupCompleted = data.game_setup_completed; cultistKillVotes = data.cultist_kill_votes || {}; cultistKillTarget = data.cultist_kill_target;
      lobbyReadyCount = data.lobby_ready_count; lobbyReadyPlayers = data.lobby_ready_players || [];
      votingSubPhase = data.voting_sub_phase; votingNominations = data.voting_nominations || {}; nominatedSpeakers = data.nominated_speakers || []; currentSpeaker = data.current_speaker; votersReadyForExecutionCount = data.voters_ready_for_execution_count; votingFinalVotes = data.voting_final_votes || {};
      duskReadyCount = data.dusk_ready_count;
      updateGUI();
    });
    socket.on('private_player_state', data => { 
        playerHand = data.hand; 
        playerRole = data.role; 
        playerStatusEffects = data.status_effects; 
        playerIsAlive = data.is_alive; 
        playerIsAsleep = data.is_asleep; 

    // --- START OF FIX ---
    // The 'if' condition was removed. We *want* this data to update
    // in the background. The updateGUI() call is now triggered
    // *after* the contract dialog is closed.
    // --- END OF FIX ---
    if (currentPhase !== "Evening" || roundNumber !== 0) {
        updateGUI();
    }
    });
    socket.on('action_confirmed', data => console.log('✔️', data.message));
    socket.on('error', data => { alert(`Error: ${data.message}`); console.error(data.message); });
    socket.on('sleep_prompt', data => { announcementsArea.innerHTML += `<p class="text-yellow-300">${data.message}</p>`; announcementsArea.scrollTop = announcementsArea.scrollHeight; updateGUI(); });
    socket.on('cultist_wake_up', data => { announcementsArea.innerHTML += `<p class="text-red-300 font-bold">${data.message}</p>`; announcementsArea.scrollTop = announcementsArea.scrollHeight; updateGUI(); });
    // --- START OF TWEAK 1 ---
    let roleData = null;
    let contractData = null;

    socket.on('reveal_role', data => {
        playerRole = data.role; // This is CRITICAL for the contract logic
        roleData = data;
        // If contract data already arrived, start the popup chain
        if (contractData) {
            showRoleRevealDialog(roleData, contractData);
        }
    });
    
    socket.on('prompt_for_contract', (data) => {
        contractData = data;
        // If role data already arrived, start the popup chain
        if (roleData) {
            showRoleRevealDialog(roleData, contractData);
        }
    });
    // --- END OF TWEAK 1 ---

    // --- ADD THIS HANDLER ---
    // --- ADD THIS HANDLER ---
    socket.on('game_has_reset', data => {
        alert(data.message); // Shows "The game was reset by an admin. Reloading..."
        location.reload(); // Force the page to reload
    });
    // --- END OF NEW HANDLER ---
    socket.on('private_announcement', data => {
        showPrivateMessageDialog("A Private Message", data.message);
    });

    socket.on('show_player_hand', data => {
        showRevealedHandDialog(data.player_name, data.hand);
    });

    socket.on('show_third_eye_vision', data => {
        showThirdEyeVisionDialog(data.vision);
    });

    socket.on('prompt_compulsion_initial', data => {
        showCompulsionInitialDialog(data.is_selected);
    });

    socket.on('prompt_compulsion_resolution', () => {
        showCompulsionResolutionDialog();
    });

    socket.on('prompt_harbinger_kill', () => {
        showHarbingerKillDialog();
    });
    
    socket.on('play_tolling_bell', () => {
        playTollingBell();
    });
    // --- START OF NEW LISTENER ---
    socket.on('prompt_resurrection_assist', (data) => {
        showResurrectionAssistDialog(data);
    });
    // --- END OF NEW LISTENER ---
    // START: ADD THE NEW, CORRECT LISTENER HERE
    // This targets our new button: 'global-reset-button'
    document.getElementById('global-reset-button').addEventListener('click', () => {
        if (confirm("are you sure you want to reset the game?")) {
            socket.emit('reset_game_request');
        }
    });
    // END: ADD THE NEW, CORRECT LISTENER
    document.addEventListener('DOMContentLoaded', updateGUI);

    let timerId = null;

    function playBirdChirps() {
        Tone.start();
        const synth = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.1, sustain: 0.1, release: 0.1 }
        }).toDestination();

        const notes = ["C5", "D5", "E5", "G5", "A5"];
        
        const now = Tone.now();
        for (let i = 0; i < 5; i++) {
            const note = notes[Math.floor(Math.random() * notes.length)];
            const time = now + i * 0.15 + Math.random() * 0.1;
            synth.triggerAttackRelease(note, "32n", time);
        }
    }

    function playTollingBell() {
        Tone.start();
        const bell = new Tone.PolySynth(Tone.MembraneSynth, {
            pitchDecay: 0.05,
            octaves: 10,
            oscillator: { type: 'sine' },
            envelope: {
                attack: 0.001,
                decay: 0.4,
                sustain: 0.01,
                release: 1.4,
                attackCurve: 'exponential'
            }
        });

        const reverb = new Tone.Reverb({
            decay: 5,
            preDelay: 0.01
        }).toDestination();
        
        bell.connect(reverb);
        
        const now = Tone.now();
        bell.triggerAttackRelease("C2", "8n", now);
        bell.triggerAttackRelease("C2", "8n", now + 0.7);
        bell.triggerAttackRelease("C2", "8n", now + 1.4);
    }

    // --- START: NEW TOOLTIP FUNCTIONS ---
    const tooltipContainer = document.getElementById('status-tooltip-container');

    /**
     * Maps an effect key (e.g., 'hand_of_glory_protection') to the
     * correct CSS class for its mini-banner.
     */
    function getTooltipClassForEffect(effect) {
      // Use the STATUS_UI_MAP to find the right class
      const ui = STATUS_UI_MAP[effect];
      if (ui && ui.bannerClasses) {
          // It's a full banner effect, use its classes
          // We need to return the *first* class that defines the style
          if (effect === 'doppelganger_pending' || effect === 'mark_of_the_beast') return 'cursed-banner';
          if (effect === 'hand_of_glory_protection') return 'hand-of-glory-banner';
          if (effect === 'eternal_winter') return 'snowy-banner';
          if (effect === 'immolated' || effect === 'burning') return 'burning';
          if (effect === 'violent_delights_quest') return 'violent-delights-banner';
          if (effect === 'divine_protection') return 'halo-effect';
          if (effect === 'lazarus_effect') return 'decaying';
      }

      // It's a simple effect, map it to a simple tooltip style
      switch(effect) {
        case 'harbinger_quest':
          return 'tooltip-harbinger';
        case 'silence':
          return 'tooltip-silence';
        case 'delirium':
          return 'tooltip-delirium';
        case 'vote_restriction':
          return 'tooltip-vote_restriction';
        
        // --- Default Fallback ---
        default:
          return 'tooltip-harbinger'; // Default to a noticeable style
      }
    }

    /**
     * Shows the tooltip stack for a given player element
     */
    function showTooltip(e) {
      const target = e.currentTarget; 
      const effectsString = target.dataset.statusEffects;
      
      tooltipContainer.innerHTML = ''; // Clear previous items
      
      if (!effectsString) {
        return; // Do nothing if there are no effects
      }
      
      const effects = effectsString.split(',');
      
      // --- Create a new tooltip item for EACH effect ---
      effects.forEach(effectName => {
        const effectDiv = document.createElement('div');
        effectDiv.className = 'status-tooltip-item'; // Base class
        
        // Add the specific banner style class
        const styleClass = getTooltipClassForEffect(effectName);
        effectDiv.classList.add(styleClass);
        // --- START OF TWEAK 1 ---
          let effectText = effectName.replace(/_/g, ' ');
          if (effectName === 'delirium') {
              effectText = 'Delirious';
          }
          effectDiv.textContent = effectText;
          // --- END OF TWEAK 1 ---
        tooltipContainer.appendChild(effectDiv);
      });
      
      // Now, position the container
      const targetRect = target.getBoundingClientRect();
      tooltipContainer.style.display = 'flex'; // Use flex to show it
      
      // Get dimensions *after* it's visible
      const containerRect = tooltipContainer.getBoundingClientRect();
      const panelRect = playerListArea.getBoundingClientRect();

      // Position: 10px to the LEFT of the player list panel,
      // aligned vertically with the player name.
      tooltipContainer.style.top = (targetRect.top + window.scrollY) + 'px';
      tooltipContainer.style.left = (panelRect.left - containerRect.width - 10) + 'px';
    }

    /**
     * Hides the tooltip container
     */
    function hideTooltip() {
      tooltipContainer.style.display = 'none';
      tooltipContainer.innerHTML = ''; // Clear items
    }

    // Special wrapper for touch to prevent scrolling
    function showTooltipTouch(e) {
      e.preventDefault();
      showTooltip(e);
    }
    // --- END: NEW TOOLTIP FUNCTIONS ---


    function updateGUI(){
      effectBannersContainer.innerHTML = '';
      if (globalStatusEffects.Carnage) {
        const banner = document.createElement('div');
        banner.className = 'w-full text-center font-bold uppercase p-1 rounded-md text-white text-center bg-red-600 border-red-400 animate-pulse-flame';
        banner.style.setProperty('--shadow-color-start', '0 0 8px rgba(255, 80, 80, 0.4)');
        banner.style.setProperty('--shadow-color-end', '0 0 25px rgba(255, 80, 80, 0.7)');
        banner.textContent = 'CARNAGE IN PROGRESS';
        effectBannersContainer.appendChild(banner);
      }
      
      for (const key in globalStatusEffects) {
          const ui = STATUS_UI_MAP[key];
          if (ui && ui.bannerText) {
              const banner = document.createElement('div');
              banner.className = 'w-full text-center font-bold uppercase p-1 rounded-md';
              banner.classList.add(...ui.bannerClasses.split(' '));
              banner.textContent = ui.bannerText;
              effectBannersContainer.appendChild(banner);
          }
      }

      const bannersToShow = new Set();
      for (const key in playerStatusEffects) {
          if (STATUS_UI_MAP[key] && !STATUS_UI_MAP[key].isPrivate) {
              bannersToShow.add(key);
          }
      }

      // Show private banners only to the affected player
      if (playerId) {
          for (const key in playerStatusEffects) {
              if (STATUS_UI_MAP[key] && STATUS_UI_MAP[key].isPrivate) {
                  bannersToShow.add(key);
              }
          }
      }

      if (!playerIsAlive) {
          bannersToShow.add('silence');
      }

      bannersToShow.forEach(key => {
          const ui = STATUS_UI_MAP[key];
          if (ui && ui.bannerText) {
              const banner = document.createElement('div');
              banner.className = 'w-full text-center font-bold uppercase p-2 rounded-md';
              banner.classList.add(...ui.bannerClasses.split(' '));
              banner.textContent = ui.bannerText;

              if (key === 'eternal_winter') {
                  generateSnowflakes(banner);
              }
              
              if (ui.shadowStart) {
                banner.classList.add('animate-pulse-flame');
                banner.style.setProperty('--shadow-color-start', `0 0 8px ${ui.shadowStart}`);
                banner.style.setProperty('--shadow-color-end', `0 0 25px ${ui.shadowEnd}`);
              }
              effectBannersContainer.appendChild(banner);
          }
      });

      let phaseText = currentPhase.toUpperCase();
      if (currentPhase === 'Voting') {
        phaseText += ` - ${votingSubPhase.toUpperCase()}`;
      }
      phaseBanner.textContent = `${phaseText}, ROUND ${roundNumber}`;
      
      if(timerId) clearInterval(timerId);
      const timers = { "Voting_Nomination": 30, "Voting_Speaking": 30, "Voting_Execution": 30 };
      const timerKey = currentPhase === 'Voting' ? `${currentPhase}_${votingSubPhase}` : currentPhase;
      if (timers[timerKey]) startTimer(timers[timerKey]);
      else timerDisplay.textContent = "No timer";

      if(currentPhase === "Lobby") progressDisplay.textContent = `${lobbyReadyCount}/${desiredPlayersCount} Players Ready`;
      else if (currentPhase === 'Voting' && votingSubPhase === 'Speaking') {
        progressDisplay.textContent = currentSpeaker ? `Speaking: ${currentSpeaker}` : 'Waiting for next speaker...';
      } else {
        progressDisplay.textContent = '';
      }

      playerHandDiv.innerHTML = "";
      if(playerHand.length){
        playerHandDiv.className = 'flex flex-col flex-grow overflow-y-auto gap-2 pr-2';
        playerHand.forEach(c => {
          const cardDiv = document.createElement('div');
          cardDiv.className = 'bg-gray-700 p-3 rounded-lg shadow-md border border-gray-600 hover:border-blue-500 hover:bg-gray-600 transition duration-200 cursor-pointer flex items-center justify-center';
          cardDiv.onclick = () => showCardDetails(c);
          const cardTitle = document.createElement('h4');
          cardTitle.className = 'font-bold text-white text-sm text-center';
          cardTitle.textContent = c.name;
          cardDiv.appendChild(cardTitle);
          playerHandDiv.appendChild(cardDiv);
        });
      } else {
        playerHandDiv.className = 'flex flex-col flex-grow overflow-y-auto';
        playerHandDiv.innerHTML = `<p class="text-gray-400 text-center mt-4">No cards in hand.</p>`;
      }

      announcementsArea.innerHTML = publicAnnouncements.map(a => `<p>${a}</p>`).join('');
      announcementsArea.scrollTop = announcementsArea.scrollHeight;

      playerListArea.innerHTML = "";
      if (alivePlayersInfo.length > 0) {
        const aliveH = document.createElement('h4');
        aliveH.className = 'text-base font-semibold mb-2 text-center text-white';
        aliveH.textContent = 'Alive Players';
        playerListArea.appendChild(aliveH);
        alivePlayersInfo.forEach(p => {
            const pe = document.createElement('div');
            let classes = ['p-2', 'my-1', 'bg-gray-700', 'rounded-md', 'text-center'];
            for (const effect in p.status_effects) {
                if (STATUS_UI_MAP[effect] && STATUS_UI_MAP[effect].highlightClasses) {
                    classes.push(...STATUS_UI_MAP[effect].highlightClasses.split(' '));
                }
            }
            if (p.is_asleep) {
                classes.push(...'border-2 border-purple-400 ring-2 ring-purple-500'.split(' '));
            }
            if (currentSpeaker === p.name) {
                classes.push(...'border-4 border-cyan-400 ring-4 ring-cyan-500 animate-pulse-flame'.split(' '));
            }
            if (currentPhase === 'Lobby' && lobbyReadyPlayers.includes(p.player_id)) {
                classes.push('border-2', 'border-green-400');
            }
            // --- START OF TOOLTIP IMPLEMENTATION ---
            
            // 1. Determine which effects to show
            // Use playerStatusEffects for my player, p.status_effects for others
            const effectsSource = (p.player_id === playerId) ? playerStatusEffects : p.status_effects;
            let effectsList = [];
            for (const effectKey in effectsSource) {
                const ui = STATUS_UI_MAP[effectKey];
                
                // Only add if it's a known, visible effect
                if (ui && (ui.bannerText || ui.highlightClasses)) {
                    // If it's me, show all my effects (public and private)
                    if (p.player_id === playerId) {
                        effectsList.push(effectKey);
                    } 
                    // If it's someone else, only show public effects
                    else if (!ui.isPrivate) {
                        effectsList.push(effectKey);
                    }
                }
            }

            // 2. If there are effects, add the data and event listeners
            if (effectsList.length > 0) {
                pe.dataset.statusEffects = effectsList.join(',');
                
                // Add event listeners for mouse
                pe.addEventListener('mousedown', showTooltip);
                pe.addEventListener('mouseup', hideTooltip);
                pe.addEventListener('mouseleave', hideTooltip);
                
                // Add event listeners for touch
                pe.addEventListener('touchstart', showTooltipTouch, { passive: false }); // passive:false to allow preventDefault
                pe.addEventListener('touchend', hideTooltip);
            }
            // --- END OF TOOLTIP IMPLEMENTATION ---
            pe.className = classes.join(' ');
            let content = p.name;
            
            if (currentPhase === 'Voting' && votingSubPhase === 'Nomination') {
                const nominators = Object.keys(votingNominations).filter(nominator => votingNominations[nominator].includes(p.name));
                if (nominators.length > 0) content += ` <span class="text-xs text-cyan-300">(${nominators.join(', ')})</span>`;
            }
            if (playerRole === 'Cultist' && currentPhase === 'Night') {
                const voters = Object.keys(cultistKillVotes).filter(voter => cultistKillVotes[voter] === p.name);
                if (voters.length > 0) {
                    pe.style.borderColor = '#f87171';
                    content += ` <span class="text-xs text-red-300">(${voters.join(', ')})</span>`;
                }
            }
            pe.innerHTML = content;
            playerListArea.appendChild(pe);
        });
      }

      if(deadPlayersInfo.length){
        const deadH = document.createElement('h4');
        deadH.className = 'text-base font-semibold mt-4 mb-2 text-center text-white';
        deadH.textContent = 'Dead Players';
        playerListArea.appendChild(deadH);
        deadPlayersInfo.forEach(p => {
          const pe = document.createElement('div');
          pe.className = 'p-2 my-1 bg-gray-900 text-gray-500 rounded-md text-center line-through border-2 border-yellow-400 ring-2 ring-yellow-500';
          pe.textContent = p.name;
          playerListArea.appendChild(pe);
        });
      }
      updateActionButton();
    }

    function generateSnowflakes(banner) {
        const snowflakeCount = 30;
        for (let i = 0; i < snowflakeCount; i++) {
            let snowflake = document.createElement('div');
            snowflake.className = 'snowflake';
            snowflake.style.left = `${Math.random() * 100}%`;
            snowflake.style.animationDuration = `${(Math.random() * 5) + 5}s`;
            snowflake.style.animationDelay = `${Math.random() * 5}s`;
            const size = Math.random() * 2 + 1;
            snowflake.style.width = `${size}px`;
            snowflake.style.height = `${size}px`;
            banner.appendChild(snowflake);
        }
    }

    function startTimer(sec){
      const start = lastPhaseStartTime;
      timerId = setInterval(() => {
        const rem = sec - ((Date.now()/1000) - start);
        if (rem >= 0) timerDisplay.textContent = `Time Left: ${Math.ceil(rem)}s`;
        else clearInterval(timerId);
      }, 1000);
    }

function updateActionButton(){
      actionButton.disabled = true;
      actionButton.className = 'action-button w-full disabled-button';
      actionButton.textContent = "Waiting...";

      if(currentPhase === "Lobby"){
        const namedPlayers = alivePlayersInfo.filter(p => !p.name.startsWith("Guest_"));
        const amIReady = lobbyReadyPlayers.includes(playerId);

        if(!desiredPlayersCount) { 
            actionButton.textContent = "Set Player Count"; 
            actionButton.onclick = showSetPlayerCountDialog; 
            actionButton.disabled = false; 
        } else if(namedPlayers.length < desiredPlayersCount) {
            actionButton.textContent = `Waiting for ${desiredPlayersCount - namedPlayers.length} more players...`;
        } else if (amIReady) {
            actionButton.textContent = "Waiting for other players...";
        } else { 
            actionButton.textContent = "Ready to Start"; 
            actionButton.onclick = () => socket.emit('start_game_request'); 
            actionButton.disabled = false; 
        }
        if(!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        return;
      }
      if(currentPhase === "Evening" || currentPhase === "Dusk"){
        const me = alivePlayersInfo.find(p => p.player_id === playerId) || deadPlayersInfo.find(p => p.player_id === playerId);
        
        if (currentPhase === "Evening" && playerStatusEffects.harbinger_quest) {
            const questData = playerStatusEffects.harbinger_quest;
            if (roundNumber >= questData.execute_at_round) {
                actionButton.textContent = "Choose Harbinger Victim";
                actionButton.onclick = showHarbingerKillDialog;
                actionButton.disabled = false;
                actionButton.className = 'action-button w-full kill-ready-button';
                return;
            }
        }

        const hasReadied = currentPhase === "Dusk" && (me ? me.has_readied_dusk : false);
        const hasSubmitted = currentPhase === "Evening" && (me ? me.has_submitted_evening_cards : false);
        
        let disabled = false;
        if (currentPhase === "Dusk") {
            disabled = hasReadied;
        } else { // Evening logic
            const canAct = playerIsAlive || (!playerIsAlive && playerHand.length > 0);
            // --- START OF FIX ---
            // The delirium check has been removed. Delirium should not prevent a player
            // from ending their turn, only from playing cards (which is handled elsewhere).
            disabled = !canAct || hasSubmitted;
            // --- END OF FIX ---
        }
        
        actionButton.textContent = currentPhase === "Dusk" ? "Ready for Evening" : "Confirm Cards";
        actionButton.onclick = currentPhase === "Dusk" ? () => socket.emit('ready_for_evening') : confirmEveningCards;
        actionButton.disabled = disabled;
        
        if (!disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasReadied || hasSubmitted) actionButton.textContent = "Waiting for other players...";
        return;
      }
      if(currentPhase === "Morning") {
        const me = alivePlayersInfo.find(p => p.player_id === playerId);
        const hasReadied = me ? me.has_readied_morning : false;
        actionButton.textContent = "Proceed to Voting";
        actionButton.onclick = () => socket.emit('proceed_to_voting');
        actionButton.disabled = !playerIsAlive || hasReadied;
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasReadied) actionButton.textContent = "Waiting for others...";
        return;
      }
      if(currentPhase === "ApocalypseVote") {
        const hasVoted = apocalypseVotes[playerId];
        actionButton.textContent = `Vote on ${apocalypseVoteTarget}`;
        actionButton.onclick = showApocalypseVoteDialog;
        const am_i_target = alivePlayersInfo.find(p => p.name === apocalypseVoteTarget)?.player_id === playerId;
        actionButton.disabled = !playerIsAlive || am_i_target || hasVoted;
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
        if (hasVoted) actionButton.textContent = "Waiting for other votes...";
        return;
      }
      if(currentPhase === "Night"){
        const totalPlayers = alivePlayersInfo.length + deadPlayersInfo.length;
        const allAsleep = nightAsleepCount >= totalPlayers;
        const isCultist = playerRole === "Cultist" && playerIsAlive && allAsleep;
        if (isCultist) {
            if (cultistKillTarget) {
                actionButton.textContent = `Confirm Kill: ${cultistKillTarget}`;
                actionButton.onclick = () => socket.emit('confirm_cultist_kill');
                actionButton.className = 'action-button w-full kill-ready-button';
                actionButton.disabled = false;
            } else {
                actionButton.textContent = "Vote to Kill";
                actionButton.onclick = showKillVoteDialog;
                actionButton.className = 'action-button w-full kill-vote-button';
                actionButton.disabled = false;
            }
        } else {
            actionButton.textContent = playerIsAsleep ? "Awaken" : "Sleep";
            actionButton.onclick = () => socket.emit('toggle_sleep');
            actionButton.disabled = false;
            actionButton.className = playerIsAsleep ? 'action-button w-full' : 'action-button w-full sleep-button';
        }
        if(!actionButton.disabled) actionButton.classList.remove('disabled-button');
        return;
      }
      if(currentPhase === "Voting") {
        const me = alivePlayersInfo.find(p => p.player_id === playerId);

        if ('vote_restriction' in playerStatusEffects) {
            actionButton.textContent = "Cannot Participate (Screams from the Void)";
            actionButton.disabled = true;
            actionButton.className = 'action-button w-full disabled-button';
            return;
        }

        if (votingSubPhase === 'Nomination') {
          actionButton.textContent = "Nominate a Player";
          actionButton.onclick = showNominationDialog;
          actionButton.disabled = !playerIsAlive;
        } else if (votingSubPhase === 'Speaking') {
          const isReady = me ? me.is_ready_for_execution : false;
          const allSpeakersDone = currentSpeaker === null && nominatedSpeakers.length > 0;
          actionButton.textContent = allSpeakersDone ? "Ready for Execution Vote" : "Waiting for speakers...";
          actionButton.onclick = allSpeakersDone ? () => socket.emit('ready_for_execution_vote') : null;
          actionButton.disabled = !playerIsAlive || !allSpeakersDone || isReady;
          if (isReady) actionButton.textContent = "Waiting for others...";
        } else if (votingSubPhase === 'Execution') {
          const hasVoted = me ? me.has_voted : false;
          actionButton.textContent = "Vote to Execute";
          actionButton.onclick = showExecutionVoteDialog;
          actionButton.disabled = !playerIsAlive || hasVoted;
          if (hasVoted) actionButton.textContent = "Waiting for other votes...";
        }
        if (!actionButton.disabled) actionButton.className = 'action-button w-full bg-blue-600 hover:bg-blue-700';
      }
    }

    function createDialog(title){
      const overlay = document.createElement('div');
      overlay.className = 'dialog-overlay';
      document.body.appendChild(overlay);
      const dialogContent = document.createElement('div');
      dialogContent.className = 'dialog-content';
      overlay.appendChild(dialogContent);
      const h2 = document.createElement('h2');
      h2.className = 'text-xl font-bold mb-4 text-center';
      h2.textContent = title;
      dialogContent.appendChild(h2);
      const dialogBody = document.createElement('div');
      dialogBody.className = 'dialog-body';
      dialogContent.appendChild(dialogBody);
      const closeBtn = document.createElement('button');
      closeBtn.textContent = 'Close';
      closeBtn.className = 'action-button mt-4 bg-red-600 hover:bg-red-700 text-white'; // <-- ADDED 'text-white'
      closeBtn.onclick = () => overlay.remove();
      return {overlay, dialogContent, dialogBody, closeButton: closeBtn};
    }

    function showNameInputDialog(){
      const {overlay, dialogContent, dialogBody, closeButton} = createDialog("Enter Your Name");
      closeButton.remove();
      const input = document.createElement('input');
      input.type = 'text'; input.placeholder = 'Your Name'; input.className = 'w-full p-2 rounded bg-gray-700 text-white mb-4';
      dialogBody.appendChild(input);
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const btn = document.createElement('button');
      btn.textContent = 'Confirm Name'; btn.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
      btn.onclick = () => { 
        Tone.start();
        const val = input.value.trim(); 
        if(val){ 
            socket.emit('player_name_submit',{name:val}); 
            overlay.remove(); 
        } else { 
            alert("Name required."); 
        } 
      };
      buttonContainer.appendChild(btn);
      dialogContent.appendChild(buttonContainer);
      input.addEventListener('keypress', e => { if(e.key==='Enter') btn.click(); });
      input.focus();
    }

    function showSetPlayerCountDialog(){
      const {overlay, dialogContent, dialogBody, closeButton} = createDialog("Set Total Players");
      closeButton.remove();
      const input = document.createElement('input');
      input.type = 'number'; input.min = 3; input.max = 15; input.value = 3; input.className = 'w-full p-2 rounded bg-gray-700 text-white mb-4';
      dialogBody.appendChild(input);
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const btn = document.createElement('button');
      btn.textContent = 'Confirm Player Count'; btn.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
      btn.onclick = () => { const cnt = parseInt(input.value,10); if(cnt>=3 && cnt<=15){ socket.emit('set_desired_player_count',{count:cnt}); overlay.remove(); } else { alert("Must be between 3 and 15"); } };
      buttonContainer.appendChild(btn);
      dialogContent.appendChild(buttonContainer);
      input.addEventListener('keypress', e => { if(e.key==='Enter') btn.click(); });
      input.focus();
    }

    function showRoleRevealDialog(role_data, contract_data){
        // --- START OF FIX ---
        // This line was missing. It creates the actual dialog.
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Your Role & Objective");
        // --- END OF FIX ---

        closeButton.remove();
        // --- TWEAK 2A: Use role_data ---
        dialogBody.innerHTML = `<p class="text-xl font-bold mb-2">Role: <span class="${role_data.role==='Cultist'?'text-red-400':'text-blue-400'}">${role_data.role}</span></p><p class="mb-4">${role_data.objective}</p>`;
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        const confirm = document.createElement('button');
        confirm.textContent = 'Understood'; confirm.className = 'action-button bg-gray-600 hover:bg-gray-700 text-white';
        // --- TWEAK 2B: Chain the popups ---
        confirm.onclick = () => { 
            overlay.remove(); 
            showContractDialog(contract_data); // Show contract next
        };
        buttonContainer.appendChild(confirm);
        dialogContent.appendChild(buttonContainer);
    }

    // --- START: NEW CONTRACT DIALOG ---
    function showContractDialog(contract_data) {
        let selectedTarget = null;
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(`New Contract: ${contract_data.name}`);
        closeButton.remove(); // Can't close this
        
        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';
        
        // Button container
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        
        // Buttons
        const acceptButton = document.createElement('button');
        acceptButton.textContent = 'Accept Contract';
        
        const rejectButton = document.createElement('button');
        rejectButton.textContent = 'Reject Contract';
        rejectButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';

        function render() {
            dialogBody.innerHTML = ''; // Clear
            
            // Description
            const desc = document.createElement('p');
            desc.className = 'text-center mb-4';
            desc.textContent = contract_data.description;
            dialogBody.appendChild(desc);

            // --- START OF FIX: Check contract target type ---
            if (playerRole === 'Villager') {
                // Check if this contract is 'self' targeting (like Lamb of God)
                if (contract_data.target_type === 'self') {
                    // This is a self-target contract. No player list needed.
                    const selfMsg = document.createElement('p');
                    selfMsg.className = 'text-center text-blue-300 font-bold mt-4';
                    selfMsg.textContent = 'This contract applies only to you.';
                    dialogBody.appendChild(selfMsg);

                    // Button Logic: Can always accept
                    acceptButton.disabled = false;
                    acceptButton.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white';

                } else {
                    // This is an 'other' target contract (like Brother's Keeper)
                    const targetHeader = document.createElement('h4');
                    targetHeader.className = 'font-bold mb-2';
                    targetHeader.textContent = `Select 1 Player:`; // More generic
                    dialogBody.appendChild(targetHeader);
                    
                    const otherPlayers = alivePlayersInfo.filter(p => p.player_id !== playerId);
                    if (otherPlayers.length === 0) {
                        dialogBody.appendChild(document.createTextNode("No other players to select."));
                    }
                    
                    otherPlayers.forEach(p => {
                        const item = document.createElement('div');
                        item.textContent = p.name;
                        const isSelected = selectedTarget && selectedTarget.name === p.name;
                        item.className = isSelected ? selectedItemStyle : baseItemStyle;
                        item.onclick = () => {
                            selectedTarget = isSelected ? null : p;
                            render(); // Re-render to update selection
                        };
                        dialogBody.appendChild(item);
                    });
                    
                    // --- Button Logic ---
                    const canAccept = selectedTarget !== null;
                    acceptButton.disabled = !canAccept;
                    acceptButton.className = canAccept ? 'action-button bg-blue-600 hover:bg-blue-700 text-white' : 'action-button disabled-button';
                }
                
            } else { // Is a Cultist
            // --- END OF FIX ---
                const cultistMsg = document.createElement('p');
                cultistMsg.className = 'text-center text-red-400 font-bold mt-4';
                cultistMsg.textContent = 'Only Villagers may accept contracts. Your Cultist masters see this as a sign of weakness.';
                dialogBody.appendChild(cultistMsg);
                
                acceptButton.disabled = true;
                acceptButton.className = 'action-button disabled-button';
            }
        }
        
        // --- Button Click Handlers ---
        acceptButton.onclick = () => {
            // --- START OF FIX: Handle 'self' vs 'other' contracts ---
            if (playerRole === 'Villager') {
                if (contract_data.target_type === 'self') {
                    // No target name needed for 'self' contracts
                    socket.emit('contract_response', {
                        contract_key: contract_data.key,
                        accepted: true
                        // No target_player_name
                    });
                } else if (selectedTarget) {
                    // This is for 'other' contracts like Brother's Keeper
                    socket.emit('contract_response', {
                        contract_key: contract_data.key,
                        accepted: true,
                        target_player_name: selectedTarget.name
                    });
                }
            }
            // --- END OF FIX ---

    // --- START OF FIX ---
    // These were moved outside the 'if' block.
    // If the button is clicked, we *always*
    // want to close the popup and update the GUI.
    overlay.remove();
    updateGUI();
    // --- END OF FIX ---
};
        
        rejectButton.onclick = () => {
            socket.emit('contract_response', {
                contract_key: contract_data.key,
                accepted: false
            });
            overlay.remove(); // Just close
            updateGUI(); // <-- ADD THIS LINE
        };

        buttonContainer.appendChild(acceptButton);
        buttonContainer.appendChild(rejectButton);
        dialogContent.appendChild(buttonContainer);
        
        render(); // Initial render
    }
    // --- END: NEW CONTRACT DIALOG ---

    function showPrivateMessageDialog(title, message) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(title);
        closeButton.textContent = 'Understood';
        
        // Style the button
        closeButton.className = 'action-button mt-4 bg-blue-600 hover:bg-blue-700 text-white';
        
        dialogBody.innerHTML = `<p class="text-purple-300 font-bold italic text-center">${message}</p>`;

        // --- START OF NEW FIX ---
        // Create a container for the button, just like in the other popups
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        
        // Add the button to the container
        buttonContainer.appendChild(closeButton);
        
        // Add the container to the dialog
        dialogContent.appendChild(buttonContainer);
        // --- END OF NEW FIX ---
    }

    function showThirdEyeVisionDialog(vision) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Third Eye Vision");
        closeButton.textContent = 'Close Vision';
        // Make it blue
        closeButton.className = 'action-button mt-4 bg-blue-600 hover:bg-blue-700 text-white';

        if (vision && vision.length > 0) {
            let content = '<div class="space-y-3">';
            vision.forEach(item => {
                content += `
                    <div class="flex items-center justify-between bg-gray-700 p-2 rounded-md">
                        <span class="font-semibold text-purple-300">${item.player_name}:</span>
                        <span class="text-gray-200">${item.card.name}</span>
                    </div>
                `;
            });
            content += '</div>';
            dialogBody.innerHTML = content;
        } else {
            dialogBody.innerHTML = `<p class="text-gray-400 text-center">Your vision reveals nothing. No other players have cards.</p>`;
        }
        
        // Add the button container
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        buttonContainer.appendChild(closeButton);
        dialogContent.appendChild(buttonContainer);
    }

    function showCompulsionInitialDialog(isSelected) {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("A Dark Compulsion");
        
        // 1. REMOVE the default red button
        closeButton.remove(); 

        let message = `One of you has been compelled to say the word "Cultist" at least once before the next sundown. This will be on your honor. If you do not do this, you will be killed.`;
        if (isSelected) {
            message = `<strong class="text-red-400">You have been selected for compulsion.</strong><br><br>` + message;
        }
        dialogBody.innerHTML = `<p class="text-center">${message}</p>`;

        // 2. CREATE a new button container, just like in your example
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3'; // 'mt-6' adds space

        // 3. CREATE the new blue button
        const iUnderstandBtn = document.createElement('button');
        iUnderstandBtn.textContent = 'I understand';
        iUnderstandBtn.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white'; // The blue style
        iUnderstandBtn.onclick = () => {
            overlay.remove(); // The button just closes the dialog
        };

        // 4. ADD the new button to the container and the dialog
        buttonContainer.appendChild(iUnderstandBtn);
        dialogContent.appendChild(buttonContainer);
    }

    function showCompulsionResolutionDialog() {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Honor's Reckoning");
        closeButton.remove();

        dialogBody.innerHTML = `<p class="text-center mb-4">Did you successfully say the word "Cultist" at least once before sundown?</p>`;
        
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';

        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes, I am spared';
        yesButton.className = 'action-button bg-green-600 hover:bg-green-700 text-white';
        yesButton.onclick = () => {
            socket.emit('compulsion_response', { success: true });
            overlay.remove();
        };

        const noButton = document.createElement('button');
        noButton.textContent = 'No, I will die';
        noButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
        noButton.onclick = () => {
            socket.emit('compulsion_response', { success: false });
            overlay.remove();
        };

        buttonContainer.appendChild(yesButton);
        buttonContainer.appendChild(noButton);
        dialogContent.appendChild(buttonContainer);
    }

    function confirmEveningCards() {
        socket.emit('submit_evening_cards', { selected_card_ids: [], sacrifice_card_ids: [], card_targets: {} });
    }

    function showKillVoteDialog() {
        const { overlay, dialogContent, dialogBody } = createDialog("Vote to Kill");
        dialogContent.querySelectorAll('button').forEach(b => b.remove());
        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';
        const myCurrentVoteTargetName = cultistKillVotes[playerName];
        alivePlayersInfo.forEach(p => {
            if (p.name === playerName) return;
            const item = document.createElement('div');
            item.textContent = p.name;
            item.className = (p.name === myCurrentVoteTargetName) ? selectedItemStyle : baseItemStyle;
            item.onclick = () => { socket.emit('cultist_kill_vote', { target_player_name: p.name }); overlay.remove(); };
            dialogBody.appendChild(item);
        });
        // --- START OF FIX ---

        // 1. Create the button container, just like in your example
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';

        // 2. Create the button with the correct style from your example
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.className = 'action-button bg-red-600 hover:bg-red-700 text-white'; // No 'mt-4', added 'text-white'
        cancelBtn.onclick = () => overlay.remove();
        
        // 3. Add the button to the container, and the container to the dialog
        buttonContainer.appendChild(cancelBtn);
        dialogContent.appendChild(buttonContainer);
        // --- END OF FIX ---
    }

    function showApocalypseVoteDialog() {
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog(`Vote to Reveal ${apocalypseVoteTarget}'s Role?`);
        closeButton.remove();
        dialogBody.innerHTML = `<p class="text-center mb-4">If the vote fails, Carnage will be triggered!</p>`;
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        dialogBody.appendChild(buttonContainer);
        const yesButton = document.createElement('button');
        yesButton.textContent = 'Yes'; yesButton.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white';
        yesButton.onclick = () => { socket.emit('apocalypse_vote_submit', { vote: 'Yes' }); overlay.remove(); };
        buttonContainer.appendChild(yesButton);
        const noButton = document.createElement('button');
        noButton.textContent = 'No'; noButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
        noButton.onclick = () => { socket.emit('apocalypse_vote_submit', { vote: 'No' }); overlay.remove(); };
        buttonContainer.appendChild(noButton);
    }
    
    function showNominationDialog() {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Nominate Players");
      let myNominations = votingNominations[playerName] || [];

      const baseStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500';
      const selectedStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer';

      function render() {
        dialogBody.innerHTML = '<p class="mb-2 text-sm text-gray-400">Select up to two players to nominate. Your nominations are public.</p>';
        alivePlayersInfo.forEach(p => {
          if (p.name === playerName) return;
          const item = document.createElement('div');
          item.textContent = p.name;
          item.className = myNominations.includes(p.name) ? selectedStyle : baseStyle;
          item.onclick = () => {
            if (myNominations.includes(p.name)) {
              myNominations = myNominations.filter(t => t !== p.name);
            } else if (myNominations.length < 2) {
              myNominations.push(p.name);
            }
            render();
          };
          dialogBody.appendChild(item);
        });
      }
      
      closeButton.remove();
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      
      const confirmBtn = document.createElement('button');
      confirmBtn.textContent = 'Confirm Nominations';
      confirmBtn.className = 'action-button bg-blue-600 hover:bg-blue-700';
      confirmBtn.onclick = () => {
        socket.emit('nominate_player', { targets: myNominations });
        overlay.remove();
      };
      
      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'action-button bg-red-600 hover:bg-red-700';
      cancelBtn.onclick = () => overlay.remove();

      buttonContainer.appendChild(confirmBtn);
      buttonContainer.appendChild(cancelBtn);
      dialogContent.appendChild(buttonContainer);
      render();
    }

    function showExecutionVoteDialog() {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Vote to Execute");
      closeButton.remove();
      
      let description = "Choose one of the speakers to execute.";
      if (playerStatusEffects.extra_vote && !playerStatusEffects.vote_restriction) {
        description = "EXTRA VOTE: Your vote will count as two.";
      } else if (playerStatusEffects.extra_vote && playerStatusEffects.vote_restriction) {
        description = "EXTRA VOTE: You can vote despite being restricted.";
      }
      dialogBody.innerHTML = `<p class="mb-2 text-sm text-gray-400">${description}</p>`;
      
      nominatedSpeakers.forEach(name => {
        const item = document.createElement('div');
        item.textContent = name;
        item.className = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-red-500';
        item.onclick = () => {
          socket.emit('submit_execution_vote', { target: name });
          overlay.remove();
        };
        dialogBody.appendChild(item);
      });

      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';

      const abstainBtn = document.createElement('button');
      abstainBtn.textContent = 'Abstain';
      abstainBtn.className = 'action-button bg-gray-500 hover:bg-gray-600';
      abstainBtn.onclick = () => {
        socket.emit('abstain_execution_vote');
        overlay.remove();
      };

      const cancelBtn = document.createElement('button');
      cancelBtn.textContent = 'Cancel';
      cancelBtn.className = 'action-button bg-red-600 hover:bg-red-700';
      cancelBtn.onclick = () => overlay.remove();

      buttonContainer.appendChild(abstainBtn);
      buttonContainer.appendChild(cancelBtn);
      dialogContent.appendChild(buttonContainer);
    }

    function showCardDetails(card) {
      const { overlay, dialogContent, dialogBody, closeButton } = createDialog(card.name);
      closeButton.remove();
      dialogBody.innerHTML = `<p class="mb-4 text-gray-300"><em>${card.description}</em></p><div class="text-sm"><p><strong class="font-semibold text-gray-100">Playable In:</strong> ${card.phase_restriction.join(', ')}</p><p><strong class="font-semibold text-gray-100">Sacrifice Cost:</strong> ${card.sacrifice_cards} card(s)</p></div>`;
      const buttonContainer = document.createElement('div');
      buttonContainer.className = 'mt-6 flex flex-col gap-3';
      const playButton = document.createElement('button');
      playButton.textContent = 'Play Card';
      playButton.className = 'action-button bg-blue-600 hover:bg-blue-700 text-white';
      playButton.onclick = () => { initiateCardPlay(card, { overlay, dialogContent, dialogBody }); };
      const cancelButton = document.createElement('button');
      cancelButton.textContent = 'Cancel';
      cancelButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
      cancelButton.onclick = () => overlay.remove();

      const canPlayInPhase = card.phase_restriction.includes(currentPhase) || card.phase_restriction.includes("Any");
      const isDelirious = 'delirium' in playerStatusEffects;
      let canPlay = false;

      if (card.name === 'Feed the Maggots' || card.name === 'Lazarus') {
          if (!playerIsAlive) {
              canPlay = true;
          } else {
              playButton.textContent = 'Can Only Play When Dead';
          }
      } else if (isDelirious && card.name !== 'I Saw the Light') {
          playButton.textContent = 'Cannot Play (Delirious)';
      } else if (!canPlayInPhase) {
          playButton.textContent = 'Cannot Play Now';
      } else {
          if (playerIsAlive && !card.dead_card) {
              canPlay = true;
          }
          else if (!playerIsAlive && card.dead_card) {
              canPlay = true;
          }
      }
      
      if (!canPlay) {
          playButton.disabled = true;
          playButton.className = 'action-button disabled-button';
      }

      buttonContainer.appendChild(playButton);
      buttonContainer.appendChild(cancelButton);
      dialogContent.appendChild(buttonContainer);
    }

function showHarbingerKillDialog() {
        let selectedVictim = null; // This will store the player you've selected
        const { overlay, dialogContent, dialogBody } = createDialog("Harbinger of Doom: Choose Your Victim");
        dialogContent.querySelectorAll('button').forEach(b => b.remove()); // Remove the default "Close" button

        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-red-700 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-red-500 text-white rounded-md cursor-pointer ring-2 ring-white';

        // Create a container for our dynamic buttons
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        dialogContent.appendChild(buttonContainer);

        function render() {
            // Clear the existing content to redraw it
            dialogBody.innerHTML = `<p class="text-center mb-4">Three rounds have passed. Choose a player to kill.</p>`;
            buttonContainer.innerHTML = '';

            // Draw the list of potential victims
            alivePlayersInfo.forEach(p => {
                if (p.player_id === playerId) return; // You can't kill yourself
                const item = document.createElement('div');
                item.textContent = p.name;
                
                // Use a different style for the selected player
                item.className = (selectedVictim && selectedVictim.player_id === p.player_id) ? selectedItemStyle : baseItemStyle;
                
                // When a player is clicked, update the selection and re-render the dialog
                item.onclick = () => {
                    selectedVictim = p;
                    render();
                };
                dialogBody.appendChild(item);
            });

            // --- Button Logic ---
            const confirmButton = document.createElement('button');
            const cancelButton = document.createElement('button');

            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'action-button bg-gray-600 hover:bg-gray-700';
            cancelButton.onclick = () => overlay.remove();

            if (selectedVictim) {
                // If a victim is selected, the confirm button is active
                confirmButton.textContent = `Confirm Kill: ${selectedVictim.name}`;
                confirmButton.className = 'action-button kill-ready-button';
                confirmButton.disabled = false;
                confirmButton.onclick = () => {
                    socket.emit('harbinger_kill', { target_name: selectedVictim.name });
                    overlay.remove();
                };
            } else {
                // If no victim is selected, the confirm button is disabled
                confirmButton.textContent = 'Confirm Kill';
                confirmButton.className = 'action-button disabled-button';
                confirmButton.disabled = true;
            }
            
            buttonContainer.appendChild(confirmButton);
            buttonContainer.appendChild(cancelButton);
        }

        render(); // This initial call draws the dialog for the first time
    }
    
    function showResurrectionAssistDialog(data) {
        // data = { ritual_id, caster_name, target_name }
        let selectedSacrifices = []; // Array of card objects
        // --- START OF FIX ---
        // 1. We only get these four items from createDialog
        const { overlay, dialogContent, dialogBody, closeButton } = createDialog("Resurrection Ritual");
        // 2. We create our own buttonContainer here, just like in showHarbingerKillDialog
        const buttonContainer = document.createElement('div');
        buttonContainer.className = 'mt-6 flex flex-col gap-3';
        dialogContent.appendChild(buttonContainer);
        // --- END OF FIX ---
        closeButton.remove(); // Can't close this dialog

        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';
        const disabledItemStyle = 'p-2 my-1 bg-gray-800 text-gray-500 rounded-md cursor-not-allowed';

        function render() {
            dialogBody.innerHTML = ''; // Clear
            buttonContainer.innerHTML = ''; // Clear

            const msg = document.createElement('p');
            msg.className = 'text-center mb-4';
            msg.innerHTML = `<strong class="text-purple-300">${data.caster_name}</strong> is using black magic to resurrect <strong class="text-gray-400">${data.target_name}</strong>! You have been selected to assist. You must sacrifice 2 cards to help, or you can sabotage the ritual.`;
            dialogBody.appendChild(msg);

            const sacrificeHeader = document.createElement('h4');
            sacrificeHeader.className = 'font-bold mt-4 mb-2';
            sacrificeHeader.textContent = `Select 2 Cards to Sacrifice:`;
            dialogBody.appendChild(sacrificeHeader);

            if (playerHand.length < 2) {
                 const errorMsg = document.createElement('p');
                 errorMsg.className = 'text-red-400 text-sm';
                 errorMsg.textContent = 'You do not have enough cards to sacrifice.';
                 dialogBody.appendChild(errorMsg);
            }
            
            playerHand.forEach(c => {
                const item = document.createElement('div');
                item.textContent = c.name;
                const isSelected = selectedSacrifices.find(s => s.id === c.id);
                let isDisabled = !isSelected && selectedSacrifices.length >= 2;

                item.className = isDisabled ? disabledItemStyle : (isSelected ? selectedItemStyle : baseItemStyle);
                item.onclick = () => {
                    if (isDisabled) return;
                    if (isSelected) {
                        selectedSacrifices = selectedSacrifices.filter(s => s.id !== c.id);
                    } else {
                        selectedSacrifices.push(c);
                    }
                    render();
                };
                dialogBody.appendChild(item);
            });

            // --- Button Logic ---
            const sacrificeButton = document.createElement('button');
            sacrificeButton.textContent = 'Sacrifice 2 Cards';
            const canSacrifice = playerHand.length >= 2 && selectedSacrifices.length === 2;
            sacrificeButton.disabled = !canSacrifice;
            sacrificeButton.className = canSacrifice ? 'action-button bg-blue-600 hover:bg-blue-700 text-white' : 'action-button disabled-button';
            sacrificeButton.onclick = () => {
                socket.emit('submit_ritual_response', {
                    ritual_id: data.ritual_id,
                    sacrificed_card_ids: selectedSacrifices.map(c => c.id)
                });
                overlay.remove();
            };

            const sabotageButton = document.createElement('button');
            sabotageButton.textContent = 'Sabotage Ritual';
            sabotageButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
            sabotageButton.onclick = () => {
                socket.emit('submit_ritual_response', {
                    ritual_id: data.ritual_id,
                    sacrificed_card_ids: [] // Empty array means sabotage
                });
                overlay.remove();
            };

            buttonContainer.appendChild(sacrificeButton);
            buttonContainer.appendChild(sabotageButton);
        }

        render();
    }

    function initiateCardPlay(card, dialogElements) {
      if (card.name === 'Feed the Maggots' || card.name === 'Lazarus') {
          socket.emit('play_special_card', { card_id: card.id });
          dialogElements.overlay.remove();
          return;
      }

      const targetTypes = ["other_player", "two_players", "dead_player", "self", "other", "multi_target_ritual"];
      if (targetTypes.includes(card.target_type)) {
          promptForPlayerTarget(card, dialogElements);
      } else {
          dialogElements.overlay.remove();
          let eventName;
          if (currentPhase === 'Evening' || currentPhase === 'Dusk') eventName = 'submit_evening_cards';
          else if (currentPhase === 'Voting') eventName = 'play_voting_card';
          else eventName = 'play_any_phase_card'; 
          socket.emit(eventName, { selected_card_ids: [card.id], sacrifice_card_ids: [], card_targets: {} });
      }
    }

    function promptForPlayerTarget(card, dialogElements) {
        let selectedTargets = []; // For standard targeting
        let selectedRitualTarget = []; // For ritual: [dead_player_name]
        let selectedRitualAssistants = []; // For ritual: [living_1, living_2, living_3]
        let selectedSacrifices = []; 
        const { overlay, dialogContent, dialogBody } = dialogElements;
        dialogContent.querySelector('h2').textContent = `Play: ${card.name}`;
        dialogContent.querySelectorAll('button').forEach(b => b.remove());
        const baseItemStyle = 'p-2 my-1 bg-gray-600 rounded-md cursor-pointer hover:bg-gray-500 transition duration-150 ease-in-out';
        const selectedItemStyle = 'p-2 my-1 bg-blue-500 text-white rounded-md cursor-pointer hover:bg-blue-600 transition duration-150 ease-in-out';
        const disabledItemStyle = 'p-2 my-1 bg-gray-800 text-gray-500 rounded-md cursor-not-allowed';

        function render() {
            dialogBody.innerHTML = ''; // Clear body
            
            // --- START: NEW RITUAL LOGIC ---
            if (card.target_type === 'multi_target_ritual') {
                // --- Part 1: Select Dead Target ---
                const targetHeader = document.createElement('h4');
                targetHeader.className = 'font-bold mb-2';
                targetHeader.textContent = `Select 1 Dead Player to Resurrect:`;
                dialogBody.appendChild(targetHeader);

                if (deadPlayersInfo.length === 0) {
                    dialogBody.appendChild(document.createTextNode("There are no dead players to resurrect."));
                }
                deadPlayersInfo.forEach(p => {
                    const item = document.createElement('div');
                    item.textContent = p.name;
                    const isSelected = selectedRitualTarget.includes(p.name);
                    item.className = isSelected ? selectedItemStyle : baseItemStyle;
                    item.onclick = () => {
                        selectedRitualTarget = isSelected ? [] : [p.name]; // Only allow one
                        render();
                    };
                    dialogBody.appendChild(item);
                });

                // --- Part 2: Select Living Assistants ---
                const assistHeader = document.createElement('h4');
                assistHeader.className = 'font-bold mt-4 mb-2';
                assistHeader.textContent = `Select 3 Living Players to Assist:`;
                dialogBody.appendChild(assistHeader);

                const eligibleAssistants = alivePlayersInfo.filter(p => p.player_id !== playerId);
                if (eligibleAssistants.length < 3) {
                     dialogBody.appendChild(document.createTextNode("Not enough living players to assist."));
                }
                eligibleAssistants.forEach(p => {
                    const item = document.createElement('div');
                    item.textContent = p.name;
                    const isSelected = selectedRitualAssistants.includes(p.name);
                    let isDisabled = !isSelected && selectedRitualAssistants.length >= 3;
                    
                    item.className = isDisabled ? disabledItemStyle : (isSelected ? selectedItemStyle : baseItemStyle);
                    
                    item.onclick = () => {
                        if (isDisabled) return;
                        if (isSelected) {
                            selectedRitualAssistants = selectedRitualAssistants.filter(t => t !== p.name);
                        } else {
                            selectedRitualAssistants.push(p.name);
                        }
                        render();
                    };
                    dialogBody.appendChild(item);
                });
                
            // --- END: NEW RITUAL LOGIC ---

            } else if (card.target_type !== 'self' && card.target_type !== 'other') {
                // --- This is the ORIGINAL logic for all other cards ---
                const numTargets = card.target_type === 'two_players' ? 2 : 1;
                const targetList = card.target_type === 'dead_player' ? deadPlayersInfo : alivePlayersInfo;
                const targetHeader = document.createElement('h4');
                targetHeader.className = 'font-bold mb-2';
                targetHeader.textContent = `Select ${numTargets} Target Player(s):`;
                dialogBody.appendChild(targetHeader);
                
                const fullTargetList = [...targetList];
                if (card.target_type === 'other_player') {
                    const self = alivePlayersInfo.find(p => p.player_id === playerId) || deadPlayersInfo.find(p => p.player_id === playerId);
                    if(self) fullTargetList.push(self);
                }

                [...new Map(fullTargetList.map(item => [item['player_id'], item])).values()].forEach(p => {
                    if (card.target_type === 'other_player' && p.player_id === playerId && card.name !== 'I Saw the Light') return;
                    const item = document.createElement('div');
                    item.textContent = p.name;
                    item.className = selectedTargets.includes(p.name) ? selectedItemStyle : baseItemStyle;
                    item.onclick = () => {
                        if (selectedTargets.includes(p.name)) {
                            selectedTargets = selectedTargets.filter(t => t !== p.name);
                        } else {
                            if (selectedTargets.length < numTargets) selectedTargets.push(p.name);
                            else if (numTargets === 1) selectedTargets = [p.name];
                        }
                        render();
                    };
                    dialogBody.appendChild(item);
                });
            } else if (card.target_type === 'self') {
                selectedTargets = [playerName];
            }

            // --- Sacrifice Logic (Unchanged, but vital) ---
            if (card.sacrifice_cards > 0) {
                const sacrificeHeader = document.createElement('h4');
                sacrificeHeader.className = 'font-bold mt-4 mb-2';
                sacrificeHeader.textContent = `Select ${card.sacrifice_cards} Card(s) to Sacrifice:`;
                dialogBody.appendChild(sacrificeHeader);

                const availableForSacrifice = playerHand.filter(c => c.id !== card.id);

                if (availableForSacrifice.length < card.sacrifice_cards) {
                     const errorMsg = document.createElement('p');
                     errorMsg.className = 'text-red-400 text-sm';
                     errorMsg.textContent = 'Not enough cards in hand to sacrifice.';
                     dialogBody.appendChild(errorMsg);
                }
                
                availableForSacrifice.forEach(c => {
                    const item = document.createElement('div');
                    item.textContent = c.name;
                    const isSelected = selectedSacrifices.find(s => s.id === c.id);
                    item.className = isSelected ? selectedItemStyle : baseItemStyle;
                    item.onclick = () => {
                        if (isSelected) {
                            selectedSacrifices = selectedSacrifices.filter(s => s.id !== c.id);
                        } else {
                            if (selectedSacrifices.length < card.sacrifice_cards) {
                                selectedSacrifices.push(c);
                            }
                        }
                        render();
                    };
                    dialogBody.appendChild(item);
                });
            }

            // --- Button & Confirmation Logic (Updated) ---
            let targetsMet = false;
            if (card.target_type === 'multi_target_ritual') {
                targetsMet = selectedRitualTarget.length === 1 && selectedRitualAssistants.length === 3;
            } else {
                const numTargetsRequired = (card.target_type === 'self' || card.target_type === 'none' || card.target_type === 'other') ? 0 : (card.target_type === 'two_players' ? 2 : 1);
                targetsMet = selectedTargets.length === numTargetsRequired || (card.target_type === 'self') || (card.target_type === 'other');
            }
            
            const sacrificesMet = selectedSacrifices.length === card.sacrifice_cards;
            const canConfirm = targetsMet && sacrificesMet;

            // --- Button rendering (Updated) ---
            if (!dialogContent.querySelector('.action-button')) {
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'mt-6 flex flex-col gap-3';
                const confirmButton = document.createElement('button');
                confirmButton.textContent = 'Confirm Play';
                const cancelButton = document.createElement('button');
                cancelButton.textContent = 'Cancel';
                cancelButton.className = 'action-button bg-red-600 hover:bg-red-700 text-white';
                cancelButton.onclick = () => overlay.remove();
                buttonContainer.appendChild(confirmButton);
                buttonContainer.appendChild(cancelButton);
                dialogContent.appendChild(buttonContainer);
            }
            const confirmButton = dialogContent.querySelector('button:not(.bg-red-600)');
            confirmButton.disabled = !canConfirm;
            confirmButton.className = canConfirm ? 'action-button bg-blue-600 hover:bg-blue-700 text-white' : 'action-button disabled-button';
            
            confirmButton.onclick = () => {
                if (!canConfirm) return;
                
                let eventName;
                if (currentPhase === 'Evening' || currentPhase === 'Dusk') eventName = 'submit_evening_cards';
                else if (currentPhase === 'Voting') eventName = 'play_voting_card';
                else eventName = 'play_any_phase_card';
                
                // --- UPDATED: Build correct target object ---
                let cardTargets = {};
                if (card.target_type === 'multi_target_ritual') {
                    cardTargets = {
                        [card.id]: {
                            target: selectedRitualTarget[0],
                            assistants: selectedRitualAssistants
                        }
                    };
                } else {
                    cardTargets = { [card.id]: selectedTargets };
                }
                
                socket.emit(eventName, { 
                    selected_card_ids: [card.id], 
                    sacrifice_card_ids: selectedSacrifices.map(c => c.id), 
                    card_targets: cardTargets
                });
                overlay.remove();
            };
        }
        render();
    }
    // --- Tutorial Logic ---
    function showTutorial() {
        const tutorialModal = document.getElementById('tutorial-modal');
        tutorialModal.classList.remove('hidden');

        const tutorialPages = [
            {
                title: "WELCOME TO CULTISTS!",
                content: "This is a game of social deduction, deception, and survival. You are either a humble <strong>Villager</strong> trying to root out evil, or a devout <strong>Cultist</strong> working to kill the non-believers."
            },
            {
                title: "CHANGES & FIXES",
                content: "<br><strong> The Apocalypse</strong> has been fixed and now works as intended. <br><strong>False Idol</strong> can now be played to end <strong>The Apocalypse</strong> before voting begins!<br><br><strong>Contracts</strong> have been added to the game!<br><br>Two new cards, <strong>Doppelgänger</strong> and <strong>Resurrection Ritual</strong>, have been added!<br><br>Doppelgänger lets you steal another player's role. Why kill the Cultists when you can become one yourself?<br><br>Resurrection Ritual allows you (and three friends) to bring one of the dead back to life, but be wary of sabotage!"
            },
            {
                title: "ROLES",
                content: "Start the game with three cards as either a <strong>Cultist</strong> or a <strong>Villager</strong>.<br><br>As a <strong>Villager</strong>, your objective is eliminate all of the <strong>Cultists</strong>!<br><br>As a <strong>Cultist</strong>, your objective is to kill all of the <strong>Villagers</strong>!<br><br>After you are killed, you will become <strong>Dead</strong>. You will lose your cards (except for <strong>Feed the Maggots</strong> and <strong>Resurrection</strong>) and receive new cards to influence the game. You cannot speak, gesture, or vote, but you can still lead your side to victory!"
            },
            {
                title: "POINTS",
                content: "<strong>CULTISTS!</strong> is played in multiple rounds (usually best of three or five). Whomever earns the most points wins! <br><br>Regardless of whether you are dead or alive, if your side wins by the end of the game, you will earn 2 points.<br><br>But be careful, Cultists! Among you may be an <strong>Enlightened Cultist</strong>. Their goal is to be the only living Cultist. <br><br>If they are the only Cultist left, this will be announced. If they survive until the following Morning, they automatically win and earn 4 points.<br><br> Points can also be earned by signing a <strong>Contract</strong> at the start of the game."
            },
            {
                title: "NEW MECHANIC: CONTRACTS!",
                content: "Each player will receive a <strong>Contract</strong>, but only Villagers can sign them! These are secondary objectives to complete over the course of the game. <br><br>If you accept and sign your Contract, you will earn 1 extra point if you succeed, but lose 1 point if you fail!<br><br>For example, <strong>Brother's Keeper</strong> requires you to select another player who must survive until the end of the game, so do everything you can to protect them!"
            },
            {
                title: "GAMEPLAY",
                content: "Each round consist of four phases: <strong>Morning</strong>, <strong>Voting</strong>, <strong>Evening</strong>, and <strong>Night</strong>.<br><br>During the <strong>Morning</strong>, learn who was killed the previous <strong>Night</strong>, hear announcements, and debate.<br><br>During <strong>Voting</strong>, nominate and vote to execute players suspected of being Cultists!<br><br>During <strong>Evening</strong>, play cards from your hand.<br><br>During <strong>Night</strong>, everyone closes their eyes. Cultists then awaken and vote on who to kill."
            },
            {
                title: "CARDS",
                content: "You will receive a new card every Morning.<br><br>Cards can sabotage your opponents, reveal new information, and protect you from attacks! Information about each card can be viewed by tapping the card on the left.<br><br>Many cards require you to sacrifice cards in order to play them.<br><br>Some cards cause temporary in-person effects. For example, if <strong>Silence</strong> is played against you, you cannot speak or gesture in-person while the yellow banner is present!"
            },
        ];

        let currentPage = 0;
        const totalPages = tutorialPages.length;
        const contentContainer = document.getElementById('tutorial-content');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const skipBtn = document.getElementById('skip-btn');
        const progressDotsContainer = document.getElementById('progress-dots');
        progressDotsContainer.innerHTML = ''; // Clear any previous dots

        for (let i = 0; i < totalPages; i++) {
            const dot = document.createElement('div');
            dot.classList.add('w-3', 'h-3', 'rounded-full', 'bg-gray-600', 'progress-dot');
            progressDotsContainer.appendChild(dot);
        }
        const progressDots = progressDotsContainer.children;

        function showPage(pageIndex) {
            const page = tutorialPages[pageIndex];
            contentContainer.innerHTML = `
                <h2 class="tutorial-title text-5xl md:text-6xl font-bold text-purple-400 text-center mb-4">${page.title}</h2>
                <p class="text-base md:text-lg leading-relaxed text-center">${page.content}</p>
            `;
            updateNavigation();
        }

        function updateNavigation() {
            prevBtn.disabled = currentPage === 0;
            if (currentPage === totalPages - 1) {
                nextBtn.textContent = "Finish";
            } else {
                nextBtn.textContent = "Next";
            }

            for (let i = 0; i < progressDots.length; i++) {
                if (i === currentPage) {
                    progressDots[i].classList.remove('bg-gray-600');
                    progressDots[i].classList.add('bg-purple-400');
                } else {
                    progressDots[i].classList.remove('bg-purple-400');
                    progressDots[i].classList.add('bg-gray-600');
                }
            }
        }

        function closeModal() {
            tutorialModal.classList.add('hidden');
        }

        prevBtn.onclick = () => {
            if (currentPage > 0) {
                currentPage--;
                showPage(currentPage);
            }
        };

        nextBtn.onclick = () => {
            if (currentPage < totalPages - 1) {
                currentPage++;
                showPage(currentPage);
            } else {
                closeModal();
            }
        };

        skipBtn.onclick = closeModal;
        
        showPage(currentPage);
    }
  </script>
</body>
</html>
